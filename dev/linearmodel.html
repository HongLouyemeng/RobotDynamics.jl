<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Linear Models · RobotDynamics</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">RobotDynamics</span></div><form class="docs-search" action="search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="index.html">Introduction</a></li><li><span class="tocitem">Getting Started</span><ul><li><a class="tocitem" href="models.html">1. Setting up a Dynamics Model</a></li><li><a class="tocitem" href="dynamics_evaluation.html">2. Evaluating the Dynamics</a></li></ul></li><li><span class="tocitem">Documentation</span><ul><li><a class="tocitem" href="discretization.html">Discretization</a></li><li><a class="tocitem" href="knotpoints.html"><code>KnotPoint</code> type</a></li><li><a class="tocitem" href="liemodel.html">Models with Rotations</a></li><li><a class="tocitem" href="rigidbody.html">Rigid Bodies</a></li><li class="is-active"><a class="tocitem" href="linearmodel.html">Linear Models</a><ul class="internal"><li class="toplevel"><a class="tocitem" href="#Linearizing-and-Discretizing-a-Model-(experimental)-1"><span>Linearizing and Discretizing a Model (experimental)</span></a></li><li class="toplevel"><a class="tocitem" href="#Example-1"><span>Example</span></a></li></ul></li><li><a class="tocitem" href="finite_diff.html">Finite Differencing</a></li><li><a class="tocitem" href="dynamics_api.html">Dynamics API</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Documentation</a></li><li class="is-active"><a href="linearmodel.html">Linear Models</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="linearmodel.html">Linear Models</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/RoboticExplorationLab/RobotDynamics.jl/blob/master/docs/src/linearmodel.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Linear-Models-1"><a class="docs-heading-anchor" href="#Linear-Models-1">Linear Models</a><a class="docs-heading-anchor-permalink" href="#Linear-Models-1" title="Permalink"></a></h1><p>RobotDynamics supports the easy construction of linear models. By defining a linear model, the relevant dynamics and jacobian functions are predefined for you. This can result in signicant speed ups compared to a naive  specification of a standard continuous model. </p><article class="docstring"><header><a class="docstring-binding" id="RobotDynamics.LinearModel" href="#RobotDynamics.LinearModel"><code>RobotDynamics.LinearModel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">LinearModel{n,m,T} &lt;: AbstractModel</code></pre><p>A concrete type for creating efficient linear model representations. This model type will automatically define the continuous or discrete version of the dynamics and jacobian functions. Supports continuous/discrete, time invariant/varying, and affine models.</p><p><strong>Constructors</strong></p><pre><code class="language-none">LinearModel(A::AbstractMatrix, B::AbstractMatrix, [dt=0, use_static]) # time invariant
LinearModel(A::AbstractMatrix, B::AbstractMatrix, d::AbstractVector, [dt=0, use_static]) # time invariant affine
LinearModel(A::Vector{TA}, B::Vector{TB}, [times::AbstractVector, dt::Real=0, use_static]) # time varying
LinearModel(A::Vector{TA}, B::Vector{TB}, d::Vector{Td}, [times::AbstractVector, dt=0, use_static]) # time varying affine

LinearModel(n::Integer, m::Integer, [is_affine=false, times=1:0, dt=0, use_static]) # constructor with zero dynamics matrices</code></pre><p>By default, the model is assumed to be continuous unless a non-zero dt is specified. For time varying models, <code>searchsortedlast</code> is  called on the <code>times</code> vector to get the discrete time index from the continuous time. The <code>use_static</code> keyword is automatically specified based on array size, but can be turned off in case of excessive compilation times.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RoboticExplorationLab/RobotDynamics.jl/blob/65e454e68a4feb0d90c6d204a716306aa9742f0a/src/linearmodel.jl#L10-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobotDynamics.LinearizedModel" href="#RobotDynamics.LinearizedModel"><code>RobotDynamics.LinearizedModel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">LinearizedModel{M,L,T} &lt;: AbstractLinearModel</code></pre><p>A container for the linearized model that holds the full nonlinear model, the linearized model, and the trajectory of linearization points. The same dynamics and jacobian functions can still be called on the <code>LinearizedModel</code> type.</p><p><strong>Constructors</strong></p><pre><code class="language-none">LinearizedModel(nonlinear_model::AbstractModel, Z::AbstractTrajectory; kwargs...)
LinearizedModel(nonlinear_model::AbstractModel, [z::AbstractKnotPoint]; kwargs...)</code></pre><p>Linearizes <code>nonlinear_model</code> about the trajectory <code>Z</code> or a single point <code>z</code>. If not specified, <code>z</code> is defined as the state and control defined by <code>zeros(nonlinear_model)</code>.</p><p>Linearization is, by default, on the continuous system.  </p><p><strong>Keyword Arguments</strong></p><ul><li><code>is_affine</code> - Linearize the system with an affine term, such that the new state is the same as the original state. See below for more details.</li><li><code>dt</code> - Time step. If not provided, defaults to the value in <code>Z</code> or <code>z</code>. Must be specified and non-zero for the system to be discretized. If <code>dt = NaN</code>, then the dt will be inferred from the trajectory (useful for variable step sizes).</li><li><code>integration</code> - An explicit integration method. Must also specify a non-zero dt. </li></ul><p>If <code>is_affine = false</code>, the dynamics are defined as: <span>$f(x,u) \approx f(x_0, u_0) + A \delta x + B \delta u$</span></p><p>which defines the error state <span>$\delta x = x - x_0$</span>     as the state of the linearized system. Here <span>$A$</span> and <span>$B$</span> are the partial derivative     of the dynamics with respect to the state and control, respectively.</p><p>If <code>is_affine = true</code>, the form is an affine function of the form <span>$f(x,u) \approx A x + B u + d$</span></p><p>where <span>$d = f(x_0,u_0) - A x_0 - B u_0$</span>, which maintains the same definition of the state.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RoboticExplorationLab/RobotDynamics.jl/blob/65e454e68a4feb0d90c6d204a716306aa9742f0a/src/linearization.jl#L1-L33">source</a></section></article><h1 id="Linearizing-and-Discretizing-a-Model-(experimental)-1"><a class="docs-heading-anchor" href="#Linearizing-and-Discretizing-a-Model-(experimental)-1">Linearizing and Discretizing a Model (experimental)</a><a class="docs-heading-anchor-permalink" href="#Linearizing-and-Discretizing-a-Model-(experimental)-1" title="Permalink"></a></h1><p>Many systems with complicated nonlinear dynamics can be simplified by linearizing them about a fixed point or a trajectory. This can allow the use of specialized and faster trajectory optimization methods for these linear systems. The functions that RobotDynamics provides also discretize the system. </p><article class="docstring"><header><a class="docstring-binding" id="RobotDynamics.discretize!" href="#RobotDynamics.discretize!"><code>RobotDynamics.discretize!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">discretize!(::Type{Q}, model::LinearizedModel, k)</code></pre><p>Discretize the linearized model at time step k, using integration <code>Q</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RoboticExplorationLab/RobotDynamics.jl/blob/65e454e68a4feb0d90c6d204a716306aa9742f0a/src/linearization.jl#L172-L176">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobotDynamics.update_trajectory!" href="#RobotDynamics.update_trajectory!"><code>RobotDynamics.update_trajectory!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">update_trajectory!(model::LinearizedModel, Z::AbstractTrajectory, integration::=DEFAULT_Q)</code></pre><p>Updates the trajectory inside of the <code>model</code> and relinearizes (and discretizes for discrete      models) the model about the new trajectory.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RoboticExplorationLab/RobotDynamics.jl/blob/65e454e68a4feb0d90c6d204a716306aa9742f0a/src/linearization.jl#L118-L123">source</a></section></article><h1 id="Example-1"><a class="docs-heading-anchor" href="#Example-1">Example</a><a class="docs-heading-anchor-permalink" href="#Example-1" title="Permalink"></a></h1><p>Take for example the cartpole, which can be readily linearized about it&#39;s stable point. We can use the  <code>LinearizedModel</code> to easily find the linearized system.</p><pre><code class="language-julia">using RobotDynamics
import RobotDynamics: dynamics  # the dynamics function must be imported
using StaticArrays

const RD = RobotDynamics

struct Cartpole{T} &lt;: AbstractModel
    mc::T  # mass of the cart
    mp::T  # mass of the pole
    l::T   # length of the pole
    g::T   # gravity
end

function dynamics(model::Cartpole, x, u)
    mc = model.mc   # mass of the cart in kg (10)
    mp = model.mp   # mass of the pole j(point mass at the end) in kg
    l = model.l     # length of the pole in m
    g = model.g     # gravity m/s^2

    q  = x[SA[1,2]]
    qd = x[SA[3,4]]

    s = sin(q[2])
    c = cos(q[2])

    H = SA[mc+mp mp*l*c; mp*l*c mp*l^2]
    C = SA[0 -mp*qd[2]*l*s; 0 0]
    G = SA[0, mp*g*l*s]
    B = SA[1, 0]

    qdd = -H\(C*qd + G - B*u[1])
    return [qd; qdd]
end

RD.state_dim(::Cartpole) = 4
RD.control_dim(::Cartpole) = 1

nonlinear_model = Cartpole(1.0, 1.0, 1.0, 9.81)
n = state_dim(nonlinear_model)
m = control_dim(nonlinear_model)

# stationary point for the cartpole around which to linearize
x̄ = @SVector [0., π, 0., 0.]
ū = @SVector [0.0]
dt = 0.01
knot_point = KnotPoint(x̄, ū, dt)

# creates a new LinearizedModel around stationary point
linear_model = RD.LinearizedModel(nonlinear_model, knot_point, 
    dt=dt, integration=Exponential)

δx = @SVector zeros(n)
δu = @SVector zeros(m)

# outputs linearized dynamics!
δxₖ₊₁ = discrete_dynamics(PassThrough, linear_model, δx, δu, 0.0, dt) 

@assert δxₖ₊₁ ≈ zeros(n)

F = RD.DynamicsJacobian(n,m)
discrete_jacobian!(PassThrough, F, linear_model, knot_point)

@show A = RD.get_A(F)
@show B = RD.get_B(F)
</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="rigidbody.html">« Rigid Bodies</a><a class="docs-footer-nextpage" href="finite_diff.html">Finite Differencing »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Thursday 28 January 2021 21:14">Thursday 28 January 2021</span>. Using Julia version 1.3.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
