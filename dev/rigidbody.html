<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Rigid Bodies · RobotDynamics</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">RobotDynamics</span></div><form class="docs-search" action="search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="index.html">Introduction</a></li><li><span class="tocitem">Getting Started</span><ul><li><a class="tocitem" href="models.html">1. Setting up a Dynamics Model</a></li><li><a class="tocitem" href="dynamics_evaluation.html">2. Evaluating the Dynamics</a></li></ul></li><li><span class="tocitem">Documentation</span><ul><li><a class="tocitem" href="discretization.html">Discretization</a></li><li><a class="tocitem" href="knotpoints.html"><code>KnotPoint</code> type</a></li><li><a class="tocitem" href="liemodel.html">Models with Rotations</a></li><li class="is-active"><a class="tocitem" href="rigidbody.html">Rigid Bodies</a><ul class="internal"><li><a class="tocitem" href="#Defining-a-New-Rigid-Body-Model-1"><span>Defining a New Rigid Body Model</span></a></li><li><a class="tocitem" href="#Advanced-Usage-1"><span>Advanced Usage</span></a></li></ul></li><li><a class="tocitem" href="linearmodel.html">Linear Models</a></li><li><a class="tocitem" href="finite_diff.html">Finite Differencing</a></li><li><a class="tocitem" href="dynamics_api.html">Dynamics API</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Documentation</a></li><li class="is-active"><a href="rigidbody.html">Rigid Bodies</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="rigidbody.html">Rigid Bodies</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/RoboticExplorationLab/RobotDynamics.jl/blob/master/docs/src/rigidbody.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Rigid-Bodies-1"><a class="docs-heading-anchor" href="#Rigid-Bodies-1">Rigid Bodies</a><a class="docs-heading-anchor-permalink" href="#Rigid-Bodies-1" title="Permalink"></a></h1><p>Many aerospace systems, such as airplanes, drones, spacecraft, or even underwater vehicles such as submarines, are conveniently described as a single rigid body described by its 3D position, orientation, and linear and angular velocities. Since these systems are relatively common, RobotDynamics provides the <code>RigidBody</code> model type that is a special case of the <code>LieGroupModel</code>. In fact, a <code>RigidBody</code> is simply a <code>LieGroupModel</code> with a <code>LieState</code> of <code>LieState{R,(3,6)}</code>, since we define the state vector to be <code>[r,q,v,ω]</code> where <code>r</code> is the 3D position, <code>q</code> is the orientation of the body in the world frame (<code>q</code> rotates vectors in the body frame to the world frame), <code>v</code> is the 3D linear velocity in either the world, or body frame, and <code>ω</code> is the 3D angular velocity in the body frame.</p><article class="docstring"><header><a class="docstring-binding" id="RobotDynamics.RigidBody" href="#RobotDynamics.RigidBody"><code>RobotDynamics.RigidBody</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">RigidBody{R&lt;:Rotation} &lt;: LieGroupModel</code></pre><p>Abstraction of a dynamical system with free-body dynamics, with a 12 or 13-dimensional state vector: <code>[p; q; v; ω]</code> where <code>p</code> is the 3D position, <code>q</code> is the 3 or 4-dimension attitude representation, <code>v</code> is the 3D linear velocity, and <code>ω</code> is the 3D angular velocity.</p><p><strong>Interface</strong></p><p>Any single-body system can leverage the <code>RigidBody</code> type by inheriting from it and defining the following interface:</p><pre><code class="language-julia">forces(::MyRigidBody, x, u)  # return the forces in the world frame
moments(::MyRigidBody, x, u) # return the moments in the body frame
inertia(::MyRigidBody, x, u) # return the 3x3 inertia matrix
mass(::MyRigidBody, x, u)  # return the mass as a real scalar</code></pre><p>Instead of defining <code>forces</code> and <code>moments</code> you can define the higher-level <code>wrenches</code> function 	wrenches(model::MyRigidbody, z::AbstractKnotPoint) 	wrenches(model::MyRigidbody, x, u)</p><p><strong>Rotation Parameterization</strong></p><p>A <code>RigidBody</code> model must specify the rotational representation being used. Any <code>Rotations.Rotation{3}</code> can be used, but we suggest one of the following:</p><ul><li><code>UnitQuaternion</code></li><li><code>MRP</code></li><li><code>RodriguesParam</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RoboticExplorationLab/RobotDynamics.jl/blob/942e02bed72055edef917d16a98175c78ed88750/src/rigidbody.jl#L1-L29">source</a></section></article><h2 id="Defining-a-New-Rigid-Body-Model-1"><a class="docs-heading-anchor" href="#Defining-a-New-Rigid-Body-Model-1">Defining a New Rigid Body Model</a><a class="docs-heading-anchor-permalink" href="#Defining-a-New-Rigid-Body-Model-1" title="Permalink"></a></h2><p>Let&#39;s define the simplest rigid body: a satellite moving freely in 3D space with full 6 DOF control.</p><p>We start by defining a new struct that inherits from <code>RigidBody{R}</code> and specifying the number of controls. Note that <code>state_dim</code> should NOT be specified since it is calculated automatically and depends on the number of parameters in the rotation representation <code>R</code>.</p><pre><code class="language-julia">using RobotDynamics
using Rotations
using StaticArrays, LinearAlgebra

# Define the model struct to inherit from `RigidBody{R}`
struct Satellite{R,T} &lt;: RigidBody{R}
    mass::T
    J::Diagonal{T,SVector{3,T}}
end
RobotDynamics.control_dim(::Satellite) = 6</code></pre><p>We now define a few &quot;getter&quot; methods that are required to evaluation the dynamics.</p><pre><code class="language-julia">RobotDynamics.mass(model::Satellite) = model.mass
RobotDynamics.inertia(model::Satellite) = model.J</code></pre><p>With those methods specified, all that is left to do is to define the forces and moments acting on the center of mass of the rigid body. We assume all forces are specified in the world frame and moments are specified in the body frame.</p><pre><code class="language-julia"># Define the 3D forces at the center of mass, in the world frame
function RobotDynamics.forces(model::Satellite, x::StaticVector, u::StaticVector)
    q = orientation(model, x)
    F = @SVector [u[1], u[2], u[3]]
    q*F  # world frame
end

# Define the 3D moments at the center of mass, in the body frame
function RobotDynamics.moments(model::Satellite, x::StaticVector, u::StaticVector)
    return @SVector [u[4], u[5], u[6]]  # body frame
end</code></pre><p>Alternatively, we could define the method <code>wrenches</code> directly:</p><pre><code class="language-julia">function RobotDynamics.wrenches(model::Satellite, z::AbstractKnotPoint)
    x = state(z)
    u = control(z)
    q = orientation(model, x)
    F = q * (@SVector [u[1], u[2], u[3]])
    M = @SVector [u[4], u[5], u[6]]  # body frame
    return SA[F[1], F[2], F[3], M[1], M[2], M[3]]
end</code></pre><p>which can take either an <code>AbstractKnotPoint</code> or <code>x</code> and <code>u</code> directly. By passing in a knot point, we have access to the time <code>t</code>, allowing for time-varying wrenches.</p><h3 id="Useful-Methods-1"><a class="docs-heading-anchor" href="#Useful-Methods-1">Useful Methods</a><a class="docs-heading-anchor-permalink" href="#Useful-Methods-1" title="Permalink"></a></h3><p>The following methods are provided to make it easier to define methods for rigid bodies.</p><p>To extract the individual components of the state use the following exported methods:</p><pre><code class="language-julia">position(model::RigidBody, x)
orientation(model::RigidBody, x, [renorm=false])
linear_velocity(model::RigidBody, x)
angular_velocity(model::RigidBody, x)</code></pre><p>Alternatively, you can use the following methods:</p><article class="docstring"><header><a class="docstring-binding" id="RobotDynamics.parse_state" href="#RobotDynamics.parse_state"><code>RobotDynamics.parse_state</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">parse_state(model::RigidBody{R}, x, renorm=false)</code></pre><p>Return the position, orientation, linear velocity, and angular velocity as separate vectors. The orientation will be of type <code>R</code>. If <code>renorm=true</code> and <code>R &lt;: UnitQuaternion</code> the quaternion will be renormalized.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RoboticExplorationLab/RobotDynamics.jl/blob/942e02bed72055edef917d16a98175c78ed88750/src/rigidbody.jl#L99-L105">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobotDynamics.gen_inds" href="#RobotDynamics.gen_inds"><code>RobotDynamics.gen_inds</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">gen_inds(model::RigidBody)</code></pre><p>Generate a <code>NamedTuple</code> containing the indices of the position (<code>r</code>), orientation (<code>q</code>), linear velocity (<code>v</code>), and angular velocity (<code>ω</code>) from the state vector for <code>model</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RoboticExplorationLab/RobotDynamics.jl/blob/942e02bed72055edef917d16a98175c78ed88750/src/rigidbody.jl#L58-L63">source</a></section></article><p>Another approach is to use the <a href="rigidbody.html#RobotDynamics.RBState"><code>RBState</code></a>, which is useful to describe a generic state for a rigid body, regardless of the rotation representation:</p><article class="docstring"><header><a class="docstring-binding" id="RobotDynamics.RBState" href="#RobotDynamics.RBState"><code>RobotDynamics.RBState</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">RBState{T} &lt;: StaticVector{13,T}</code></pre><p>Represents the state of a rigid body in 3D space, consisting of position, orientation, linear     velocity and angular velocity, respresented as a vector stacked in that order, with     the rotation represented as the 4 elements of a unit quaternion.</p><p>Implements the <code>StaticArrays</code> interface so can be treated as an <code>SVector</code> with additional     methods.</p><p><strong>Constructors</strong></p><pre><code class="language-none">RBState{T}(r, q, v, ω)
RBState{T}(x)
RBState(r, q, v, ω)
RBState(x)</code></pre><p>where <code>r</code>, <code>v</code>, and <code>ω</code> are three-dimensional vectors, <code>q</code> is either a <code>Rotation</code> or a     four-dimenional vector representing the parameters of unit quaternion, and <code>x</code> is a     13-dimensional vector (or tuple),</p><p><strong>Converting to a State Vector</strong></p><p>An <code>RBState</code> can be converted to a state vector for a <code>RigidBody</code> using     RBState(model::RBstate, x, [renorm=false])</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RoboticExplorationLab/RobotDynamics.jl/blob/942e02bed72055edef917d16a98175c78ed88750/src/rbstate.jl#L5-L28">source</a></section></article><h3 id="Building-a-State-Vector-1"><a class="docs-heading-anchor" href="#Building-a-State-Vector-1">Building a State Vector</a><a class="docs-heading-anchor-permalink" href="#Building-a-State-Vector-1" title="Permalink"></a></h3><p>RobotDynamics also provides several convenient methods for building rigid body state vectors. Identical to <code>AbstractModel</code>, <code>RigidBody</code> supports <code>rand</code> and <code>zeros</code>, which uniformly sample the space of rotations and provide the identity rotation, respectively.</p><p>RobotDynamics also provides the following method as a complement to <a href="rigidbody.html#RobotDynamics.parse_state"><code>parse_state</code></a> that builds the state vector from the individual components:</p><article class="docstring"><header><a class="docstring-binding" id="RobotDynamics.build_state" href="#RobotDynamics.build_state"><code>RobotDynamics.build_state</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">build_state(model::RigidBody{R}, x::RBState) where R
build_state(model::RigidBody{R}, x::AbstractVector) where R
build_state(model::RigidBody{R}, r, q, v, ω) where R</code></pre><p>Build the state vector for <code>model</code> using the <code>RBState</code> <code>x</code>. If <code>R &lt;: UnitQuaternion</code> this     returns <code>x</code> cast as an <code>SVector</code>, otherwise it will convert the quaternion in <code>x</code> to     a rotation of type <code>R</code>.</p><p>Also accepts as arguments any arguments that can be passed to the constructor of <code>RBState</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RoboticExplorationLab/RobotDynamics.jl/blob/942e02bed72055edef917d16a98175c78ed88750/src/rigidbody.jl#L129-L139">source</a></section></article><h2 id="Advanced-Usage-1"><a class="docs-heading-anchor" href="#Advanced-Usage-1">Advanced Usage</a><a class="docs-heading-anchor-permalink" href="#Advanced-Usage-1" title="Permalink"></a></h2><p>RobotDynamics provides a few specialized methods for providing extra performance or customization.</p><h3 id="Specifying-the-Velocity-Frame-1"><a class="docs-heading-anchor" href="#Specifying-the-Velocity-Frame-1">Specifying the Velocity Frame</a><a class="docs-heading-anchor-permalink" href="#Specifying-the-Velocity-Frame-1" title="Permalink"></a></h3><p>Sometimes it is convenient to represent the linear velocity in the body frame instead of the global frame. This can be changed automatically for our <code>Satellite</code> model by defining</p><pre><code class="language-julia">RobotDynamics.velocity_frame(::Satellite) = :body</code></pre><p>which overrides the default setting of <code>:world</code>. Use this same method to query the current convention, especially in defining the <code>forces</code> and <code>moments</code> or <code>wrenches</code> methods on your model. Since the forces and moments of our satellite are not functions of the velocity, we don&#39;t need to change anything.</p><h3 id="Faster-Continuous-Dynamics-Jacobians-1"><a class="docs-heading-anchor" href="#Faster-Continuous-Dynamics-Jacobians-1">Faster Continuous Dynamics Jacobians</a><a class="docs-heading-anchor-permalink" href="#Faster-Continuous-Dynamics-Jacobians-1" title="Permalink"></a></h3><p>RobotDynamics has an analytical method for evaluating the continuous dynamics Jacobian for rigid bodies. If your application only uses the continuous dynamics Jacobian, there are two ways of getting significant performance improvements:</p><h4 id=".-Specify-the-analytical-wrench-Jacobian-1"><a class="docs-heading-anchor" href="#.-Specify-the-analytical-wrench-Jacobian-1">1. Specify the analytical wrench Jacobian</a><a class="docs-heading-anchor-permalink" href="#.-Specify-the-analytical-wrench-Jacobian-1" title="Permalink"></a></h4><p>For our Satellite, we can do this by defining</p><pre><code class="language-julia">function RobotDynamics.wrench_jacobian!(F, model::Satellite, z)
    x = state(z)
    u = control(z)
    q = orientation(model, x)
    ir, iq, iv, iω, iu = RobotDynamics.gen_inds(model)
    iF = SA[1,2,3]
    iM = SA[4,5,6]
    F[iF, iq] .= Rotations.∇rotate(q, u[iF])
    F[iF, iu[iF]] .= RotMatrix(q)
    for i = 1:3
        F[iM[i], iu[i+3]] = 1
    end
    return F
end</code></pre><p>which gave us about a 60% improvement in runtime.</p><h4 id=".-Specify-the-Wrench-Jacobian-sparsity-1"><a class="docs-heading-anchor" href="#.-Specify-the-Wrench-Jacobian-sparsity-1">2. Specify the Wrench Jacobian sparsity</a><a class="docs-heading-anchor-permalink" href="#.-Specify-the-Wrench-Jacobian-sparsity-1" title="Permalink"></a></h4><p>You can get another improvement in performance by overwriting the following method:</p><article class="docstring"><header><a class="docstring-binding" id="RobotDynamics.wrench_sparsity" href="#RobotDynamics.wrench_sparsity"><code>RobotDynamics.wrench_sparsity</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">wrench_sparsity(model::RigidBody)</code></pre><p>Specify the sparsity of the wrench Jacobian of <code>model</code> as a <code>js = SMatrix{2,5,Bool,10}</code>. The elements of <code>js</code> correspond to the block elements of the wrench Jacobian:</p><pre><code class="language-julia">[∂F/∂r ∂F/∂q ∂F/∂v ∂F/∂ω ∂F/∂u;
 ∂M/∂r ∂M/∂q ∂M/∂v ∂M/∂ω ∂M/∂u]</code></pre><p>where <code>js[i,j] = false</code> if the corresponding partial derivative is always zero.</p><p>Note that this is only for performance improvement of continuous-time Jacobians of rigid bodies; specifying the sparsity is completely optional.</p><p><strong>Example</strong></p><p>For a fully-actuated satellite where <code>F = q*u[1:3]</code> and <code>M = u[4:6]</code>, the wrench sparsity would be</p><pre><code class="language-julia">SA[false true  false false true;
   false false false false true]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RoboticExplorationLab/RobotDynamics.jl/blob/942e02bed72055edef917d16a98175c78ed88750/src/rigidbody.jl#L302-L326">source</a></section></article><p>For the satellite we got a 75% improvement in runtime by specifying both the analytical wrench Jacobian and it&#39;s sparsity pattern.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="liemodel.html">« Models with Rotations</a><a class="docs-footer-nextpage" href="linearmodel.html">Linear Models »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Tuesday 18 January 2022 18:55">Tuesday 18 January 2022</span>. Using Julia version 1.3.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
