<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>1. Setting up a Dynamics Model · RobotDynamics</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">RobotDynamics</span></div><form class="docs-search" action="search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="index.html">Introduction</a></li><li><span class="tocitem">Getting Started</span><ul><li class="is-active"><a class="tocitem" href="models.html">1. Setting up a Dynamics Model</a><ul class="internal"><li><a class="tocitem" href="#Overview-1"><span>Overview</span></a></li><li><a class="tocitem" href="#Creating-a-New-Model-1"><span>Creating a New Model</span></a></li><li><a class="tocitem" href="#Time-varying-systems-1"><span>Time-varying systems</span></a></li><li><a class="tocitem" href="#Discrete-Dynamical-Systems-1"><span>Discrete Dynamical Systems</span></a></li><li><a class="tocitem" href="#Models-with-3D-Rotations-1"><span>Models with 3D Rotations</span></a></li></ul></li><li><a class="tocitem" href="dynamics_evaluation.html">2. Evaluating the Dynamics</a></li></ul></li><li><span class="tocitem">Documentation</span><ul><li><a class="tocitem" href="discretization.html">Discretization</a></li><li><a class="tocitem" href="knotpoints.html"><code>KnotPoint</code> type</a></li><li><a class="tocitem" href="liemodel.html">Models with Rotations</a></li><li><a class="tocitem" href="rigidbody.html">Rigid Bodies</a></li><li><a class="tocitem" href="linearmodel.html">Linear Models</a></li><li><a class="tocitem" href="finite_diff.html">Finite Differencing</a></li><li><a class="tocitem" href="dynamics_api.html">Dynamics API</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Getting Started</a></li><li class="is-active"><a href="models.html">1. Setting up a Dynamics Model</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="models.html">1. Setting up a Dynamics Model</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/RoboticExplorationLab/RobotDynamics.jl/blob/master/docs/src/models.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="model_section-1"><a class="docs-heading-anchor" href="#model_section-1">1. Setting up a Dynamics Model</a><a class="docs-heading-anchor-permalink" href="#model_section-1" title="Permalink"></a></h1><ul><li><a href="models.html#model_section-1">1. Setting up a Dynamics Model</a></li><ul><li><a href="models.html#Overview-1">Overview</a></li><li><a href="models.html#Creating-a-New-Model-1">Creating a New Model</a></li><li><a href="models.html#Time-varying-systems-1">Time-varying systems</a></li><li><a href="models.html#Discrete-Dynamical-Systems-1">Discrete Dynamical Systems</a></li><li><a href="models.html#Models-with-3D-Rotations-1">Models with 3D Rotations</a></li></ul></ul><h2 id="Overview-1"><a class="docs-heading-anchor" href="#Overview-1">Overview</a><a class="docs-heading-anchor-permalink" href="#Overview-1" title="Permalink"></a></h2><p>The Model type holds information about the dynamics of the system. All dynamics are assumed to be state-space models of the system of the form <span>$\dot{x} = f(x,u)$</span> where <span>$\dot{x}$</span> is the state derivative, <span>$x$</span> an <span>$n$</span>-dimensional state vector, and <span>$u$</span> in an <span>$m$</span>-dimensional control input vector. The function <span>$f$</span> can be any nonlinear function.</p><p>Many numerical methods require discrete dynamics of the form <span>$x_{k+1} = f(x_k, u_k)$</span>, where <span>$k$</span> is the time step. There many methods of performing this discretization, and RobotDynamics.jl offers several of the most common methods. See <a href="discretization.html#Model-Discretization-1">Model Discretization</a> section for more information on discretizing dynamics, as well as how to define custom integration methods.</p><h2 id="Creating-a-New-Model-1"><a class="docs-heading-anchor" href="#Creating-a-New-Model-1">Creating a New Model</a><a class="docs-heading-anchor-permalink" href="#Creating-a-New-Model-1" title="Permalink"></a></h2><p>To create a new model of a dynamical system, you need to define a new type that inherits from <code>AbstractModel</code>. You will need to then define only a few methods on your type. Let&#39;s say we want to create a model of the canonical cartpole. We start by defining our type:</p><pre><code class="language-julia">struct Cartpole{T} &lt;: AbstractModel
    mc::T  # mass of the cart
    mp::T  # mass of the pole
    l::T   # length of the pole
    g::T   # gravity
end</code></pre><p>It&#39;s often convenient to store any model parameters inside the new type (make sure they&#39;re concrete types!). If you need to store vectors or matrices, we highly recommend using StaticArrays, which are extremely fast and avoid memory allocations. For models with lots of parameters, we recommend <a href="https://github.com/mauro3/Parameters.jl">Parameters.jl</a> that makes it easy to specify default parameters.</p><p>We now just need to define two functions to complete the interface</p><pre><code class="language-julia">import RobotDynamics: dynamics  # the dynamics function must be imported

function dynamics(model::Cartpole, x, u)
    mc = model.mc   # mass of the cart in kg (10)
    mp = model.mp   # mass of the pole j(point mass at the end) in kg
    l = model.l     # length of the pole in m
    g = model.g     # gravity m/s^2

    q  = x[SA[1,2]]
    qd = x[SA[3,4]]

    s = sin(q[2])
    c = cos(q[2])

    H = SA[mc+mp mp*l*c; mp*l*c mp*l^2]
    C = SA[0 -mp*qd[2]*l*s; 0 0]
    G = SA[0, mp*g*l*s]
    B = SA[1, 0]

    qdd = -H\(C*qd + G - B*u[1])
    return [qd; qdd]
end

RobotDynamics.state_dim(::Cartpole) = 4
RobotDynamics.control_dim(::Cartpole) = 1</code></pre><p>And voila! we have a new model.</p><p>We now have a few methods automatically available to us:</p><pre><code class="language-julia">dynamics(model, z)
jacobian!(∇f, model, z)</code></pre><p>We can also use <code>size(model)</code> to get <code>(n,m)</code>, <code>rand(model)</code> to get a tuple of randomly-sampled state and control vectors, or <code>zeros(model)</code> to get 0-vectors of the state and control.</p><h3 id="Analytical-Jacobians-1"><a class="docs-heading-anchor" href="#Analytical-Jacobians-1">Analytical Jacobians</a><a class="docs-heading-anchor-permalink" href="#Analytical-Jacobians-1" title="Permalink"></a></h3><p>Instead of relying on ForwardDiff to generate our dynamics Jacobian, we can instead overwrite the method ourselves by defining the function:</p><pre><code class="language-none">jacobian!(∇f, model::Cartpole, z::AbstractKnotPoint)</code></pre><p>where <code>∇f</code> is a <code>n × (n+m)</code> matrix and <code>z</code> is an <a href="knotpoints.html#RobotDynamics.AbstractKnotPoint"><code>AbstractKnotPoint</code></a>.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>By default, RobotDynamics will NOT use the analytical continuous Jacobian when computing the discrete Jacobian, since our benchmarks have shown it is typically faster to let ForwardDiff compute the Jacobian directly on the discrete dynamics function, thereby avoiding multiple calls to <code>jacobian!</code>.</p></div></div><h2 id="Time-varying-systems-1"><a class="docs-heading-anchor" href="#Time-varying-systems-1">Time-varying systems</a><a class="docs-heading-anchor-permalink" href="#Time-varying-systems-1" title="Permalink"></a></h2><p>RobotDynamics.jl also offers support for time-varying systems. Let&#39;s say for some reason the mass of our cartpole is decreasing linearly with time. We can model this with a slight modification to the dynamics function signature:</p><pre><code class="language-julia">import RobotDynamics: dynamics

struct CartpoleTimeVarying{T} &lt;: AbstractModel
    mc::T  # initial mass of the cart
    mp::T  # mass of the pole
    l::T   # length of the pole
    g::T   # gravity
end

function dynamics(model::CartpoleTimeVarying, x, u, t)  # note extra time parameter
    mc = model.mc   # mass of the cart in kg (10)
    mp = model.mp   # mass of the pole (point mass at the end) in kg
    l = model.l     # length of the pole in m
    g = model.g     # gravity m/s^2

    # Change the mass of the cart with time
    mc = mc - 0.01*t

    q  = x[SA[1,2]]
    qd = x[SA[3,4]]

    s = sin(q[2])
    c = cos(q[2])

    H = SA[mc+mp mp*l*c; mp*l*c mp*l^2]
    C = SA[0 -mp*qd[2]*l*s; 0 0]
    G = SA[0, mp*g*l*s]
    B = SA[1, 0]

    qdd = -H\(C*qd + G - B*u[1])
    return [qd; qdd]
end

RobotDynamics.state_dim(::CartpoleTimeVarying) = 4
RobotDynamics.control_dim(::CartpoleTimeVarying) = 1</code></pre><h2 id="Discrete-Dynamical-Systems-1"><a class="docs-heading-anchor" href="#Discrete-Dynamical-Systems-1">Discrete Dynamical Systems</a><a class="docs-heading-anchor-permalink" href="#Discrete-Dynamical-Systems-1" title="Permalink"></a></h2><p>Most models are assumed to be continuous in nature, and require some integration scheme (such as a Runge-Kutta method) to convert to discrete-time dynamics. However, some systems are naturally discrete or perhaps the user has a custom integration method already applied to their system. Instead of defining the continuous dynamics function, we can directly define the discrete dynamics instead with the predefined integration type <a href="@ref"><code>PassThrough</code></a>:</p><pre><code class="language-julia"># Define the discrete dynamics function
function RobotDynamics.discrete_dynamics(::Type{PassThrough}, model::Cartpole,
        x::StaticVector, u::StaticVector, t, dt)

    mc = model.mc   # mass of the cart in kg (10)
    mp = model.mp   # mass of the pole j(point mass at the end) in kg
    l = model.l     # length of the pole in m
    g = model.g     # gravity m/s^2

    q  = x[SA[1,2]]
    qd = x[SA[3,4]]

    s = sin(q[2])
    c = cos(q[2])

    H = SA[mc+mp mp*l*c; mp*l*c mp*l^2]
    C = SA[0 -mp*qd[2]*l*s; 0 0]
    G = SA[0, mp*g*l*s]
    B = SA[1, 0]

    qdd = -H\(C*qd + G - B*u[1])
    xdot = [qd; qdd]
    return x + xdot * dt  # simple Euler integration
end</code></pre><h2 id="Models-with-3D-Rotations-1"><a class="docs-heading-anchor" href="#Models-with-3D-Rotations-1">Models with 3D Rotations</a><a class="docs-heading-anchor-permalink" href="#Models-with-3D-Rotations-1" title="Permalink"></a></h2><p>RobotDynamics.jl offers support for models with non-Euclidean state vectors, such as 3D rotations, which live in <span>$SO(3)$</span> instead of <span>$\mathbb{R}^4$</span> (quaternions) or <span>$\mathbb{R}^3$</span> (Euler angles, Modified Rodrigues Parameters, etc.). See <a href="rigidbody.html#RobotDynamics.RigidBody"><code>RigidBody</code></a> section for more details.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="index.html">« Introduction</a><a class="docs-footer-nextpage" href="dynamics_evaluation.html">2. Evaluating the Dynamics »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Tuesday 18 January 2022 18:55">Tuesday 18 January 2022</span>. Using Julia version 1.3.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
