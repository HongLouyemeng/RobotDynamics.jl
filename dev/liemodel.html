<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Models with Rotations · RobotDynamics</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">RobotDynamics</span></div><form class="docs-search" action="search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="index.html">Introduction</a></li><li><span class="tocitem">Getting Started</span><ul><li><a class="tocitem" href="models.html">1. Setting up a Dynamics Model</a></li><li><a class="tocitem" href="dynamics_evaluation.html">2. Evaluating the Dynamics</a></li></ul></li><li><span class="tocitem">Documentation</span><ul><li><a class="tocitem" href="discretization.html">Discretization</a></li><li><a class="tocitem" href="knotpoints.html"><code>KnotPoint</code> type</a></li><li class="is-active"><a class="tocitem" href="liemodel.html">Models with Rotations</a><ul class="internal"><li><a class="tocitem" href="#Defining-a-LieGroupModel-1"><span>Defining a <code>LieGroupModel</code></span></a></li><li><a class="tocitem" href="#LieGroupModel-API-1"><span><code>LieGroupModel</code> API</span></a></li></ul></li><li><a class="tocitem" href="rigidbody.html">Rigid Bodies</a></li><li><a class="tocitem" href="linearmodel.html">Linear Models</a></li><li><a class="tocitem" href="finite_diff.html">Finite Differencing</a></li><li><a class="tocitem" href="dynamics_api.html">Dynamics API</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Documentation</a></li><li class="is-active"><a href="liemodel.html">Models with Rotations</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="liemodel.html">Models with Rotations</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/RoboticExplorationLab/RobotDynamics.jl/blob/master/docs/src/liemodel.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Models-with-Rotations-1"><a class="docs-heading-anchor" href="#Models-with-Rotations-1">Models with Rotations</a><a class="docs-heading-anchor-permalink" href="#Models-with-Rotations-1" title="Permalink"></a></h1><p>In robotics, the state of our robot often depends on one or more arbitrary 3D rotations (a.k.a. orientation, attitude). Effectively representing the non-trivial group structure of rotations has been a topic of study for over 100 years, and as a result many parameterizations exists. RobotDynamics supports the types defined in <a href="https://github.com/JuliaGeometry/Rotations.jl">Rotations.jl</a>.</p><p>The <code>LieGroupModel</code> type allows users to abstract away the particular rotation representation used and will automatically create efficient methods to handle the potentially different state dimensions that result. Additionally, it defines methods for operating on the error state, which for rotations is always three-dimensional. See the discussion in the Rotaitons.jl <a href="https://github.com/JuliaGeometry/Rotations.jl#the-rotation-error-state-and-linearization">README</a> for more information on the error state.</p><div class="admonition is-compat"><header class="admonition-header">Compat</header><div class="admonition-body"><p>RobotDynamics requires <code>v1.0</code> or higher of <code>Rotations.jl</code></p></div></div><h2 id="Defining-a-LieGroupModel-1"><a class="docs-heading-anchor" href="#Defining-a-LieGroupModel-1">Defining a <code>LieGroupModel</code></a><a class="docs-heading-anchor-permalink" href="#Defining-a-LieGroupModel-1" title="Permalink"></a></h2><p>We define a <code>LieGroupModel</code> very similarly to that of a standard model. For this example, let&#39;s assume we are modeling a constellation of 2 satellites and we only care about the attitude dynamics. We will define our state to be <code>[q1, ω1, q2, ω2]</code> where <code>qi</code> and <code>ωi</code> are the orientation  and angular velocity of the <code>i</code>th satellite, respectively.</p><p>We start by defining our new type and our dynamics function</p><pre><code class="language-julia">struct SatellitePair{R,T} &lt;: LieGroupModel
    J1::SMatrix{3,3,T,9}   # inertia of satellite 1
    J2::SMatrix{3,3,T,9}   # inertia of satellite 2
end

function RobotDynamics.dynamics(model::SatellitePair, x, u)
    vs = RobotDynamics.vec_states(model, x)  # extract &quot;vector&quot; states
    qs = RobotDynamics.rot_states(model, x)  # extract attitude states
    ω1 = vs[2]  # offset index by 1 since there are now &quot;vector&quot; states before the first quaternion
    ω2 = vs[3]
    q1 = qs[1]
    q2 = qs[2]

    J1, J2 = model.J1, model.J2
    u1 = u[SA[1,2,3]]
    u2 = u[SA[4,5,6]]
    ω1dot = J1\(u1 - ω1 × (J1 * ω1))
    ω2dot = J2\(u2 - ω2 × (J2 * ω2))
    q1dot = Rotations.kinematics(q1, ω1)
    q2dot = Rotations.kinematics(q2, ω2)
    SA[
        q1dot[1], q1dot[2], q1dot[3], q1dot[4],
        ω1dot[1], ω1dot[2], ω1dot[3],
        q2dot[1], q2dot[2], q2dot[3], q2dot[4],
        ω2dot[1], ω2dot[2], ω2dot[3],
    ]
end

RobotDynamics.control_dim(::SatellitePair) = 6</code></pre><p>Before defining the functions <a href="liemodel.html#RobotDynamics.vec_states"><code>vec_states</code></a> and <a href="liemodel.html#RobotDynamics.rot_states"><code>rot_states</code></a>, we will define the type <a href="liemodel.html#RobotDynamics.LieState"><code>LieState</code></a>, which defines how our state vector is stacked or partitioned. The <code>LieState</code> only needs to know how many &quot;vector&quot; or &quot;non-rotation&quot; states exist, and where the rotations are placed in the state vector. In our example, we have a rotation, followed by 3 &quot;vector&quot; states, followed by a rotation, followed by 3 &quot;vector&quot; states, so we would define our <code>LieState</code> to be</p><pre><code class="language-julia">RobotDynamics.LieState(::SatellitePair{R}) where R = RobotDynamics.LieState(R, (0,3,3))</code></pre><p>which means we have a state with 0 vector states at the beginning, followed by a rotation, followed by 3 vector states, followed by a rotation, followed by 3 vector states, and the rotation type is <code>R</code>.</p><p>With this partitioning in mind, we can now understand the behavior of <a href="liemodel.html#RobotDynamics.vec_states"><code>vec_states</code></a> and <a href="liemodel.html#RobotDynamics.rot_states"><code>rot_states</code></a>, which simply extract the vector and attitude parts of the state as tuples of <code>SVector</code>s.</p><h2 id="LieGroupModel-API-1"><a class="docs-heading-anchor" href="#LieGroupModel-API-1"><code>LieGroupModel</code> API</a><a class="docs-heading-anchor-permalink" href="#LieGroupModel-API-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="RobotDynamics.LieGroupModel" href="#RobotDynamics.LieGroupModel"><code>RobotDynamics.LieGroupModel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">LieGroupModel &lt;: AbstractModel</code></pre><p>Abstraction of a dynamical system whose state contains at least one arbitrary rotation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RoboticExplorationLab/RobotDynamics.jl/blob/dab497eb6f596ee1beb8a7ac36a07d1b3b8da208/src/model.jl#L33-L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobotDynamics.LieState" href="#RobotDynamics.LieState"><code>RobotDynamics.LieState</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">LieState{R,P}</code></pre><p>Specifies a state with rotational components mixed in with standard vector components. All rotational components are assumed to be parameterizations of 3D rotations.</p><p><strong>Parameters</strong></p><ul><li><code>R &lt;: Rotation</code> is the rotational representation used in the state vector. Must have</li></ul><p><code>params(::Type{R})</code> defined, which returns the number of parameters used by the rotation, as well a constructor that takes each parameter as a separate scalar argument.</p><ul><li><code>P &lt;: Tuple{Vararg{Int}}</code> is a tuple of integers specifying the partitioning of the state</li></ul><p>vector. Each element of <code>P</code> specifies the length of the vector component between the rotational components, and <code>P[1]</code> and <code>P[end]</code> specify the number of vector states at the beginning and end of the state vector.</p><p><strong>Examples</strong></p><p>If we want to construct a state vector like the following: <code>[v3, q, v2, q, v3]</code> where <code>v2</code> and <code>v3</code> and vector components of length 2 and 3, respectively, and <code>q</code> is a 4-dimensional unit quaternion. The <code>LieState</code> for this state vector would be <code>LieState{UnitQuaternion{Float64},3,2,3}</code>. The length should be (3+4+2+4+3) = 16, which can be verified by <code>length(s::LieState)</code>.</p><p><strong>Constructors</strong></p><pre><code class="language-none">LieState(::Type{R}, P::Tuple{Vararg{Int}})
LieState(::Type{R}, p1::Int, p2::Int, p3::Int...)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RoboticExplorationLab/RobotDynamics.jl/blob/dab497eb6f596ee1beb8a7ac36a07d1b3b8da208/src/liestate.jl#L10-L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobotDynamics.QuatState" href="#RobotDynamics.QuatState"><code>RobotDynamics.QuatState</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">QuatState(n::Int, Q::StaticVector{&lt;:Any,Int})
QuatState(n::Int, Q::NTuple{&lt;:Any,Int})</code></pre><p>Create a <code>n</code>-dimensional <code>LieState</code> assuming <code>R = UnitQuaternion{Float64}</code> and <code>Q[i]</code> is the first index of each quaternion in the state vector.</p><p><strong>Example</strong></p><p>If we want to construct a state vector like the following: <code>[v3, q, v2, q, v3]</code> where <code>v2</code> and <code>v3</code> and vector components of length 2 and 3, respectively, and <code>q</code> is a 4-dimensional unit quaternion. Since the first quaternion starts at index 4, and the second starts at index 10, Q = [4,10]. The entire length of the vector is <code>n = 16 = 3 + 4 + 2 + 4 + 3</code>, so we would call <code>QuatState(16, SA[4,10])</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RoboticExplorationLab/RobotDynamics.jl/blob/dab497eb6f596ee1beb8a7ac36a07d1b3b8da208/src/liestate.jl#L46-L59">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobotDynamics.vec_states" href="#RobotDynamics.vec_states"><code>RobotDynamics.vec_states</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">vec_states(model::LieGroupModel, x)
vec_states(s::LieState, x)</code></pre><p>Extracts the &quot;vector&quot; states out of the state vector <code>x</code> for a <code>LieGroupModel</code>. Returns a tuple <code>v</code> of <code>SVector</code>s, where <code>length(v[i])</code> is equal to the length specified by the <code>LieState</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RoboticExplorationLab/RobotDynamics.jl/blob/dab497eb6f596ee1beb8a7ac36a07d1b3b8da208/src/liestate.jl#L97-L104">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobotDynamics.rot_states" href="#RobotDynamics.rot_states"><code>RobotDynamics.rot_states</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">vec_states(model::LieGroupModel, x)
vec_states(s::LieState, x)</code></pre><p>Extracts the rotations out of the state vector <code>x</code> for a <code>LieGroupModel</code>. Returns a tuple rotations, whose type matches the rotation type specified in the <code>LieState</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RoboticExplorationLab/RobotDynamics.jl/blob/dab497eb6f596ee1beb8a7ac36a07d1b3b8da208/src/liestate.jl#L116-L122">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="knotpoints.html">« <code>KnotPoint</code> type</a><a class="docs-footer-nextpage" href="rigidbody.html">Rigid Bodies »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Saturday 10 July 2021 17:53">Saturday 10 July 2021</span>. Using Julia version 1.3.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
