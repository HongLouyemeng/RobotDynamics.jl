var documenterSearchIndex = {"docs":
[{"location":"knotpoints.html#KnotPoint-type-1","page":"KnotPoint type","title":"KnotPoint type","text":"","category":"section"},{"location":"knotpoints.html#","page":"KnotPoint type","title":"KnotPoint type","text":"CurrentModule = RobotDynamics","category":"page"},{"location":"knotpoints.html#","page":"KnotPoint type","title":"KnotPoint type","text":"A common way of dealing with trajectories of forced dynamical systems, especially in optimization, is to represent a trajectory with a fixed number of \"knot points\", typically distributed evenly over time. Each point records the states, controls, time, and time step to the next point. It is often convenient to store all this information together, which is the purpose of the AbstractKnotPoint type. Additionally, it is almost always more efficient to index into a concatenated vector than it is to concatenate two smaller vectors, so the states and controls are stacked together in a single  n+m-dimensional vector.","category":"page"},{"location":"knotpoints.html#","page":"KnotPoint type","title":"KnotPoint type","text":"RobotDynamics.jl defines a couple different implementations of the AbstractKnotPoint interface, which can be useful depending on the application.","category":"page"},{"location":"knotpoints.html#Types-1","page":"KnotPoint type","title":"Types","text":"","category":"section"},{"location":"knotpoints.html#","page":"KnotPoint type","title":"KnotPoint type","text":"AbstractKnotPoint\nGeneralKnotPoint\nKnotPoint\nStaticKnotPoint","category":"page"},{"location":"knotpoints.html#RobotDynamics.AbstractKnotPoint","page":"KnotPoint type","title":"RobotDynamics.AbstractKnotPoint","text":"AbstractKnotPoint{Nx,Nu,V,T}\n\nStores the states, controls, time, and time step at a single point along a trajectory of a forced dynamical system with n states and m controls.\n\nInterface\n\nAll instances of AbstractKnotPoint should support the following methods:\n\nstate_dim(z)::Integer         # state vector dimension\ncontrol_dim(z)::Integer       # control vector dimension\ngetparams(z)                  # arbitrary parameters, usually the time and time step \ngetdata(z)::V                 # the underlying vector\n\n\n\n\n\n","category":"type"},{"location":"knotpoints.html#Methods-1","page":"KnotPoint type","title":"Methods","text":"","category":"section"},{"location":"knotpoints.html#","page":"KnotPoint type","title":"KnotPoint type","text":"All AbstractKnotPoint types support the following methods:","category":"page"},{"location":"knotpoints.html#","page":"KnotPoint type","title":"KnotPoint type","text":"state\ncontrol\nis_terminal\nget_z\nset_state!\nset_control!\nset_z!","category":"page"},{"location":"knotpoints.html#Mathematical-Operations-1","page":"KnotPoint type","title":"Mathematical Operations","text":"","category":"section"},{"location":"knotpoints.html#","page":"KnotPoint type","title":"KnotPoint type","text":"All AbstractKnotPoint types support addition between two knot points, addition of a knot point and a vector of length n+m, and multiplication with a scalar, all of which will return a StaticKnotPoint.","category":"page"},{"location":"dynamics_api.html#","page":"Dynamics API","title":"Dynamics API","text":"CurrentModule = RobotDynamics","category":"page"},{"location":"dynamics_api.html#Dynamics-API-1","page":"Dynamics API","title":"Dynamics API","text":"","category":"section"},{"location":"dynamics_api.html#","page":"Dynamics API","title":"Dynamics API","text":"dynamics\njacobian!\njvp!\ndiscrete_dynamics\ndiscrete_jacobian!\ndiscrete_jvp!\n∇discrete_jacobian!","category":"page"},{"location":"rigidbody.html#","page":"Rigid Bodies","title":"Rigid Bodies","text":"CurrentModule = RobotDynamics","category":"page"},{"location":"rigidbody.html#Rigid-Bodies-1","page":"Rigid Bodies","title":"Rigid Bodies","text":"","category":"section"},{"location":"rigidbody.html#","page":"Rigid Bodies","title":"Rigid Bodies","text":"Many aerospace systems, such as airplanes, drones, spacecraft, or even underwater vehicles such as submarines, are conveniently described as a single rigid body described by its 3D position, orientation, and linear and angular velocities. Since these systems are relatively common, RobotDynamics provides the RigidBody model type that is a special case of the LieGroupModel. In fact, a RigidBody is simply a LieGroupModel with a LieState of LieState{R,(3,6)}, since we define the state vector to be [r,q,v,ω] where r is the 3D position, q is the orientation of the body in the world frame (q rotates vectors in the body frame to the world frame), v is the 3D linear velocity in either the world, or body frame, and ω is the 3D angular velocity in the body frame.","category":"page"},{"location":"rigidbody.html#","page":"Rigid Bodies","title":"Rigid Bodies","text":"RigidBody","category":"page"},{"location":"rigidbody.html#RobotDynamics.RigidBody","page":"Rigid Bodies","title":"RobotDynamics.RigidBody","text":"RigidBody{R<:Rotation} <: LieGroupModel\n\nAbstraction of a dynamical system with free-body dynamics, with a 12 or 13-dimensional state vector: [p; q; v; ω] where p is the 3D position, q is the 3 or 4-dimension attitude representation, v is the 3D linear velocity, and ω is the 3D angular velocity.\n\nInterface\n\nAny single-body system can leverage the RigidBody type by inheriting from it and defining the following interface:\n\nforces(::MyRigidBody, x, u)  # return the forces in the world frame\nmoments(::MyRigidBody, x, u) # return the moments in the body frame\ninertia(::MyRigidBody, x, u) # return the 3x3 inertia matrix\nmass(::MyRigidBody, x, u)  # return the mass as a real scalar\n\nInstead of defining forces and moments you can define the higher-level wrenches function \twrenches(model::MyRigidbody, z::AbstractKnotPoint) \twrenches(model::MyRigidbody, x, u)\n\nRotation Parameterization\n\nA RigidBody model must specify the rotational representation being used. Any Rotations.Rotation{3} can be used, but we suggest one of the following:\n\nUnitQuaternion\nMRP\nRodriguesParam\n\n\n\n\n\n","category":"type"},{"location":"rigidbody.html#Defining-a-New-Rigid-Body-Model-1","page":"Rigid Bodies","title":"Defining a New Rigid Body Model","text":"","category":"section"},{"location":"rigidbody.html#","page":"Rigid Bodies","title":"Rigid Bodies","text":"Let's define the simplest rigid body: a satellite moving freely in 3D space with full 6 DOF control.","category":"page"},{"location":"rigidbody.html#","page":"Rigid Bodies","title":"Rigid Bodies","text":"We start by defining a new struct that inherits from RigidBody{R} and specifying the number of controls. Note that state_dim should NOT be specified since it is calculated automatically and depends on the number of parameters in the rotation representation R.","category":"page"},{"location":"rigidbody.html#","page":"Rigid Bodies","title":"Rigid Bodies","text":"using RobotDynamics\nusing Rotations\nusing StaticArrays, LinearAlgebra\n\n# Define the model struct to inherit from `RigidBody{R}`\nstruct Satellite{R,T} <: RigidBody{R}\n    mass::T\n    J::Diagonal{T,SVector{3,T}}\nend\nRobotDynamics.control_dim(::Satellite) = 6","category":"page"},{"location":"rigidbody.html#","page":"Rigid Bodies","title":"Rigid Bodies","text":"We now define a few \"getter\" methods that are required to evaluation the dynamics.","category":"page"},{"location":"rigidbody.html#","page":"Rigid Bodies","title":"Rigid Bodies","text":"RobotDynamics.mass(model::Satellite) = model.mass\nRobotDynamics.inertia(model::Satellite) = model.J","category":"page"},{"location":"rigidbody.html#","page":"Rigid Bodies","title":"Rigid Bodies","text":"With those methods specified, all that is left to do is to define the forces and moments acting on the center of mass of the rigid body. We assume all forces are specified in the world frame and moments are specified in the body frame.","category":"page"},{"location":"rigidbody.html#","page":"Rigid Bodies","title":"Rigid Bodies","text":"# Define the 3D forces at the center of mass, in the world frame\nfunction RobotDynamics.forces(model::Satellite, x::StaticVector, u::StaticVector)\n    q = orientation(model, x)\n    F = @SVector [u[1], u[2], u[3]]\n    q*F  # world frame\nend\n\n# Define the 3D moments at the center of mass, in the body frame\nfunction RobotDynamics.moments(model::Satellite, x::StaticVector, u::StaticVector)\n    return @SVector [u[4], u[5], u[6]]  # body frame\nend","category":"page"},{"location":"rigidbody.html#","page":"Rigid Bodies","title":"Rigid Bodies","text":"Alternatively, we could define the method wrenches directly:","category":"page"},{"location":"rigidbody.html#","page":"Rigid Bodies","title":"Rigid Bodies","text":"function RobotDynamics.wrenches(model::Satellite, z::AbstractKnotPoint)\n    x = state(z)\n    u = control(z)\n    q = orientation(model, x)\n    F = q * (@SVector [u[1], u[2], u[3]])\n    M = @SVector [u[4], u[5], u[6]]  # body frame\n    return SA[F[1], F[2], F[3], M[1], M[2], M[3]]\nend","category":"page"},{"location":"rigidbody.html#","page":"Rigid Bodies","title":"Rigid Bodies","text":"which can take either an AbstractKnotPoint or x and u directly. By passing in a knot point, we have access to the time t, allowing for time-varying wrenches.","category":"page"},{"location":"rigidbody.html#Useful-Methods-1","page":"Rigid Bodies","title":"Useful Methods","text":"","category":"section"},{"location":"rigidbody.html#","page":"Rigid Bodies","title":"Rigid Bodies","text":"The following methods are provided to make it easier to define methods for rigid bodies.","category":"page"},{"location":"rigidbody.html#","page":"Rigid Bodies","title":"Rigid Bodies","text":"To extract the individual components of the state use the following exported methods:","category":"page"},{"location":"rigidbody.html#","page":"Rigid Bodies","title":"Rigid Bodies","text":"position(model::RigidBody, x)\norientation(model::RigidBody, x, [renorm=false])\nlinear_velocity(model::RigidBody, x)\nangular_velocity(model::RigidBody, x)","category":"page"},{"location":"rigidbody.html#","page":"Rigid Bodies","title":"Rigid Bodies","text":"Alternatively, you can use the following methods:","category":"page"},{"location":"rigidbody.html#","page":"Rigid Bodies","title":"Rigid Bodies","text":"parse_state\ngen_inds","category":"page"},{"location":"rigidbody.html#RobotDynamics.parse_state","page":"Rigid Bodies","title":"RobotDynamics.parse_state","text":"parse_state(model::RigidBody{R}, x, renorm=false)\n\nReturn the position, orientation, linear velocity, and angular velocity as separate vectors. The orientation will be of type R. If renorm=true and R <: UnitQuaternion the quaternion will be renormalized.\n\n\n\n\n\n","category":"function"},{"location":"rigidbody.html#RobotDynamics.gen_inds","page":"Rigid Bodies","title":"RobotDynamics.gen_inds","text":"gen_inds(model::RigidBody)\n\nGenerate a NamedTuple containing the indices of the position (r), orientation (q), linear velocity (v), and angular velocity (ω) from the state vector for model.\n\n\n\n\n\n","category":"function"},{"location":"rigidbody.html#","page":"Rigid Bodies","title":"Rigid Bodies","text":"Another approach is to use the RBState, which is useful to describe a generic state for a rigid body, regardless of the rotation representation:","category":"page"},{"location":"rigidbody.html#","page":"Rigid Bodies","title":"Rigid Bodies","text":"RBState","category":"page"},{"location":"rigidbody.html#RobotDynamics.RBState","page":"Rigid Bodies","title":"RobotDynamics.RBState","text":"RBState{T} <: StaticVector{13,T}\n\nRepresents the state of a rigid body in 3D space, consisting of position, orientation, linear     velocity and angular velocity, respresented as a vector stacked in that order, with     the rotation represented as the 4 elements of a unit quaternion.\n\nImplements the StaticArrays interface so can be treated as an SVector with additional     methods.\n\nConstructors\n\nRBState{T}(r, q, v, ω)\nRBState{T}(x)\nRBState(r, q, v, ω)\nRBState(x)\n\nwhere r, v, and ω are three-dimensional vectors, q is either a Rotation or a     four-dimenional vector representing the parameters of unit quaternion, and x is a     13-dimensional vector (or tuple),\n\nConverting to a State Vector\n\nAn RBState can be converted to a state vector for a RigidBody using     RBState(model::RBstate, x, [renorm=false])\n\n\n\n\n\n","category":"type"},{"location":"rigidbody.html#Building-a-State-Vector-1","page":"Rigid Bodies","title":"Building a State Vector","text":"","category":"section"},{"location":"rigidbody.html#","page":"Rigid Bodies","title":"Rigid Bodies","text":"RobotDynamics also provides several convenient methods for building rigid body state vectors. Identical to AbstractModel, RigidBody supports rand and zeros, which uniformly sample the space of rotations and provide the identity rotation, respectively.","category":"page"},{"location":"rigidbody.html#","page":"Rigid Bodies","title":"Rigid Bodies","text":"RobotDynamics also provides the following method as a complement to parse_state that builds the state vector from the individual components:","category":"page"},{"location":"rigidbody.html#","page":"Rigid Bodies","title":"Rigid Bodies","text":"build_state","category":"page"},{"location":"rigidbody.html#RobotDynamics.build_state","page":"Rigid Bodies","title":"RobotDynamics.build_state","text":"build_state(model::RigidBody{R}, x::RBState) where R\nbuild_state(model::RigidBody{R}, x::AbstractVector) where R\nbuild_state(model::RigidBody{R}, r, q, v, ω) where R\n\nBuild the state vector for model using the RBState x. If R <: UnitQuaternion this     returns x cast as an SVector, otherwise it will convert the quaternion in x to     a rotation of type R.\n\nAlso accepts as arguments any arguments that can be passed to the constructor of RBState.\n\n\n\n\n\n","category":"function"},{"location":"rigidbody.html#Advanced-Usage-1","page":"Rigid Bodies","title":"Advanced Usage","text":"","category":"section"},{"location":"rigidbody.html#","page":"Rigid Bodies","title":"Rigid Bodies","text":"RobotDynamics provides a few specialized methods for providing extra performance or customization.","category":"page"},{"location":"rigidbody.html#Specifying-the-Velocity-Frame-1","page":"Rigid Bodies","title":"Specifying the Velocity Frame","text":"","category":"section"},{"location":"rigidbody.html#","page":"Rigid Bodies","title":"Rigid Bodies","text":"Sometimes it is convenient to represent the linear velocity in the body frame instead of the global frame. This can be changed automatically for our Satellite model by defining","category":"page"},{"location":"rigidbody.html#","page":"Rigid Bodies","title":"Rigid Bodies","text":"RobotDynamics.velocity_frame(::Satellite) = :body","category":"page"},{"location":"rigidbody.html#","page":"Rigid Bodies","title":"Rigid Bodies","text":"which overrides the default setting of :world. Use this same method to query the current convention, especially in defining the forces and moments or wrenches methods on your model. Since the forces and moments of our satellite are not functions of the velocity, we don't need to change anything.","category":"page"},{"location":"rigidbody.html#Faster-Continuous-Dynamics-Jacobians-1","page":"Rigid Bodies","title":"Faster Continuous Dynamics Jacobians","text":"","category":"section"},{"location":"rigidbody.html#","page":"Rigid Bodies","title":"Rigid Bodies","text":"RobotDynamics has an analytical method for evaluating the continuous dynamics Jacobian for rigid bodies. If your application only uses the continuous dynamics Jacobian, there are two ways of getting significant performance improvements:","category":"page"},{"location":"rigidbody.html#.-Specify-the-analytical-wrench-Jacobian-1","page":"Rigid Bodies","title":"1. Specify the analytical wrench Jacobian","text":"","category":"section"},{"location":"rigidbody.html#","page":"Rigid Bodies","title":"Rigid Bodies","text":"For our Satellite, we can do this by defining","category":"page"},{"location":"rigidbody.html#","page":"Rigid Bodies","title":"Rigid Bodies","text":"function RobotDynamics.wrench_jacobian!(F, model::Satellite, z)\n    x = state(z)\n    u = control(z)\n    q = orientation(model, x)\n    ir, iq, iv, iω, iu = RobotDynamics.gen_inds(model)\n    iF = SA[1,2,3]\n    iM = SA[4,5,6]\n    F[iF, iq] .= Rotations.∇rotate(q, u[iF])\n    F[iF, iu[iF]] .= RotMatrix(q)\n    for i = 1:3\n        F[iM[i], iu[i+3]] = 1\n    end\n    return F\nend","category":"page"},{"location":"rigidbody.html#","page":"Rigid Bodies","title":"Rigid Bodies","text":"which gave us about a 60% improvement in runtime.","category":"page"},{"location":"rigidbody.html#.-Specify-the-Wrench-Jacobian-sparsity-1","page":"Rigid Bodies","title":"2. Specify the Wrench Jacobian sparsity","text":"","category":"section"},{"location":"rigidbody.html#","page":"Rigid Bodies","title":"Rigid Bodies","text":"You can get another improvement in performance by overwriting the following method:","category":"page"},{"location":"rigidbody.html#","page":"Rigid Bodies","title":"Rigid Bodies","text":"wrench_sparsity","category":"page"},{"location":"rigidbody.html#RobotDynamics.wrench_sparsity","page":"Rigid Bodies","title":"RobotDynamics.wrench_sparsity","text":"wrench_sparsity(model::RigidBody)\n\nSpecify the sparsity of the wrench Jacobian of model as a js = SMatrix{2,5,Bool,10}. The elements of js correspond to the block elements of the wrench Jacobian:\n\n[∂F/∂r ∂F/∂q ∂F/∂v ∂F/∂ω ∂F/∂u;\n ∂M/∂r ∂M/∂q ∂M/∂v ∂M/∂ω ∂M/∂u]\n\nwhere js[i,j] = false if the corresponding partial derivative is always zero.\n\nNote that this is only for performance improvement of continuous-time Jacobians of rigid bodies; specifying the sparsity is completely optional.\n\nExample\n\nFor a fully-actuated satellite where F = q*u[1:3] and M = u[4:6], the wrench sparsity would be\n\nSA[false true  false false true;\n   false false false false true]\n\n\n\n\n\n","category":"function"},{"location":"rigidbody.html#","page":"Rigid Bodies","title":"Rigid Bodies","text":"For the satellite we got a 75% improvement in runtime by specifying both the analytical wrench Jacobian and it's sparsity pattern.","category":"page"},{"location":"models.html#model_section-1","page":"1. Setting up a Dynamics Model","title":"1. Setting up a Dynamics Model","text":"","category":"section"},{"location":"models.html#","page":"1. Setting up a Dynamics Model","title":"1. Setting up a Dynamics Model","text":"CurrentModule = RobotDynamics","category":"page"},{"location":"models.html#","page":"1. Setting up a Dynamics Model","title":"1. Setting up a Dynamics Model","text":"Pages = [\"models.md\"]","category":"page"},{"location":"models.html#Overview-1","page":"1. Setting up a Dynamics Model","title":"Overview","text":"","category":"section"},{"location":"models.html#","page":"1. Setting up a Dynamics Model","title":"1. Setting up a Dynamics Model","text":"The Model type holds information about the dynamics of the system. All dynamics are assumed to be state-space models of the system of the form dotx = f(xu) where dotx is the state derivative, x an n-dimensional state vector, and u in an m-dimensional control input vector. The function f can be any nonlinear function.","category":"page"},{"location":"models.html#","page":"1. Setting up a Dynamics Model","title":"1. Setting up a Dynamics Model","text":"Many numerical methods require discrete dynamics of the form x_k+1 = f(x_k u_k), where k is the time step. There many methods of performing this discretization, and RobotDynamics.jl offers several of the most common methods. See Model Discretization section for more information on discretizing dynamics, as well as how to define custom integration methods.","category":"page"},{"location":"models.html#Creating-a-New-Model-1","page":"1. Setting up a Dynamics Model","title":"Creating a New Model","text":"","category":"section"},{"location":"models.html#","page":"1. Setting up a Dynamics Model","title":"1. Setting up a Dynamics Model","text":"To create a new model of a dynamical system, you need to define a new type that inherits from AbstractModel. You will need to then define only a few methods on your type. Let's say we want to create a model of the canonical cartpole. We start by defining our type:","category":"page"},{"location":"models.html#","page":"1. Setting up a Dynamics Model","title":"1. Setting up a Dynamics Model","text":"struct Cartpole{T} <: AbstractModel\n    mc::T  # mass of the cart\n    mp::T  # mass of the pole\n    l::T   # length of the pole\n    g::T   # gravity\nend","category":"page"},{"location":"models.html#","page":"1. Setting up a Dynamics Model","title":"1. Setting up a Dynamics Model","text":"It's often convenient to store any model parameters inside the new type (make sure they're concrete types!). If you need to store vectors or matrices, we highly recommend using StaticArrays, which are extremely fast and avoid memory allocations. For models with lots of parameters, we recommend Parameters.jl that makes it easy to specify default parameters.","category":"page"},{"location":"models.html#","page":"1. Setting up a Dynamics Model","title":"1. Setting up a Dynamics Model","text":"We now just need to define two functions to complete the interface","category":"page"},{"location":"models.html#","page":"1. Setting up a Dynamics Model","title":"1. Setting up a Dynamics Model","text":"import RobotDynamics: dynamics  # the dynamics function must be imported\n\nfunction dynamics(model::Cartpole, x, u)\n    mc = model.mc   # mass of the cart in kg (10)\n    mp = model.mp   # mass of the pole j(point mass at the end) in kg\n    l = model.l     # length of the pole in m\n    g = model.g     # gravity m/s^2\n\n    q  = x[SA[1,2]]\n    qd = x[SA[3,4]]\n\n    s = sin(q[2])\n    c = cos(q[2])\n\n    H = SA[mc+mp mp*l*c; mp*l*c mp*l^2]\n    C = SA[0 -mp*qd[2]*l*s; 0 0]\n    G = SA[0, mp*g*l*s]\n    B = SA[1, 0]\n\n    qdd = -H\\(C*qd + G - B*u[1])\n    return [qd; qdd]\nend\n\nRobotDynamics.state_dim(::Cartpole) = 4\nRobotDynamics.control_dim(::Cartpole) = 1","category":"page"},{"location":"models.html#","page":"1. Setting up a Dynamics Model","title":"1. Setting up a Dynamics Model","text":"And voila! we have a new model.","category":"page"},{"location":"models.html#","page":"1. Setting up a Dynamics Model","title":"1. Setting up a Dynamics Model","text":"We now have a few methods automatically available to us:","category":"page"},{"location":"models.html#","page":"1. Setting up a Dynamics Model","title":"1. Setting up a Dynamics Model","text":"dynamics(model, z)\njacobian!(∇f, model, z)","category":"page"},{"location":"models.html#","page":"1. Setting up a Dynamics Model","title":"1. Setting up a Dynamics Model","text":"We can also use size(model) to get (n,m), rand(model) to get a tuple of randomly-sampled state and control vectors, or zeros(model) to get 0-vectors of the state and control.","category":"page"},{"location":"models.html#Analytical-Jacobians-1","page":"1. Setting up a Dynamics Model","title":"Analytical Jacobians","text":"","category":"section"},{"location":"models.html#","page":"1. Setting up a Dynamics Model","title":"1. Setting up a Dynamics Model","text":"Instead of relying on ForwardDiff to generate our dynamics Jacobian, we can instead overwrite the method ourselves by defining the function:","category":"page"},{"location":"models.html#","page":"1. Setting up a Dynamics Model","title":"1. Setting up a Dynamics Model","text":"jacobian!(∇f, model::Cartpole, z::AbstractKnotPoint)","category":"page"},{"location":"models.html#","page":"1. Setting up a Dynamics Model","title":"1. Setting up a Dynamics Model","text":"where ∇f is a n × (n+m) matrix and z is an AbstractKnotPoint.","category":"page"},{"location":"models.html#","page":"1. Setting up a Dynamics Model","title":"1. Setting up a Dynamics Model","text":"warning: Warning\nBy default, RobotDynamics will NOT use the analytical continuous Jacobian when computing the discrete Jacobian, since our benchmarks have shown it is typically faster to let ForwardDiff compute the Jacobian directly on the discrete dynamics function, thereby avoiding multiple calls to jacobian!.","category":"page"},{"location":"models.html#Time-varying-systems-1","page":"1. Setting up a Dynamics Model","title":"Time-varying systems","text":"","category":"section"},{"location":"models.html#","page":"1. Setting up a Dynamics Model","title":"1. Setting up a Dynamics Model","text":"RobotDynamics.jl also offers support for time-varying systems. Let's say for some reason the mass of our cartpole is decreasing linearly with time. We can model this with a slight modification to the dynamics function signature:","category":"page"},{"location":"models.html#","page":"1. Setting up a Dynamics Model","title":"1. Setting up a Dynamics Model","text":"import RobotDynamics: dynamics\n\nstruct CartpoleTimeVarying{T} <: AbstractModel\n    mc::T  # initial mass of the cart\n    mp::T  # mass of the pole\n    l::T   # length of the pole\n    g::T   # gravity\nend\n\nfunction dynamics(model::CartpoleTimeVarying, x, u, t)  # note extra time parameter\n    mc = model.mc   # mass of the cart in kg (10)\n    mp = model.mp   # mass of the pole (point mass at the end) in kg\n    l = model.l     # length of the pole in m\n    g = model.g     # gravity m/s^2\n\n    # Change the mass of the cart with time\n    mc = mc - 0.01*t\n\n    q  = x[SA[1,2]]\n    qd = x[SA[3,4]]\n\n    s = sin(q[2])\n    c = cos(q[2])\n\n    H = SA[mc+mp mp*l*c; mp*l*c mp*l^2]\n    C = SA[0 -mp*qd[2]*l*s; 0 0]\n    G = SA[0, mp*g*l*s]\n    B = SA[1, 0]\n\n    qdd = -H\\(C*qd + G - B*u[1])\n    return [qd; qdd]\nend\n\nRobotDynamics.state_dim(::CartpoleTimeVarying) = 4\nRobotDynamics.control_dim(::CartpoleTimeVarying) = 1","category":"page"},{"location":"models.html#Discrete-Dynamical-Systems-1","page":"1. Setting up a Dynamics Model","title":"Discrete Dynamical Systems","text":"","category":"section"},{"location":"models.html#","page":"1. Setting up a Dynamics Model","title":"1. Setting up a Dynamics Model","text":"Most models are assumed to be continuous in nature, and require some integration scheme (such as a Runge-Kutta method) to convert to discrete-time dynamics. However, some systems are naturally discrete or perhaps the user has a custom integration method already applied to their system. Instead of defining the continuous dynamics function, we can directly define the discrete dynamics instead with the predefined integration type PassThrough:","category":"page"},{"location":"models.html#","page":"1. Setting up a Dynamics Model","title":"1. Setting up a Dynamics Model","text":"# Define the discrete dynamics function\nfunction RobotDynamics.discrete_dynamics(::Type{PassThrough}, model::Cartpole,\n        x::StaticVector, u::StaticVector, t, dt)\n\n    mc = model.mc   # mass of the cart in kg (10)\n    mp = model.mp   # mass of the pole j(point mass at the end) in kg\n    l = model.l     # length of the pole in m\n    g = model.g     # gravity m/s^2\n\n    q  = x[SA[1,2]]\n    qd = x[SA[3,4]]\n\n    s = sin(q[2])\n    c = cos(q[2])\n\n    H = SA[mc+mp mp*l*c; mp*l*c mp*l^2]\n    C = SA[0 -mp*qd[2]*l*s; 0 0]\n    G = SA[0, mp*g*l*s]\n    B = SA[1, 0]\n\n    qdd = -H\\(C*qd + G - B*u[1])\n    xdot = [qd; qdd]\n    return x + xdot * dt  # simple Euler integration\nend","category":"page"},{"location":"models.html#Models-with-3D-Rotations-1","page":"1. Setting up a Dynamics Model","title":"Models with 3D Rotations","text":"","category":"section"},{"location":"models.html#","page":"1. Setting up a Dynamics Model","title":"1. Setting up a Dynamics Model","text":"RobotDynamics.jl offers support for models with non-Euclidean state vectors, such as 3D rotations, which live in SO(3) instead of mathbbR^4 (quaternions) or mathbbR^3 (Euler angles, Modified Rodrigues Parameters, etc.). See RigidBody section for more details.","category":"page"},{"location":"linearmodel.html#","page":"Linear Models","title":"Linear Models","text":"CurrentModule = RobotDynamics","category":"page"},{"location":"linearmodel.html#Linear-Models-1","page":"Linear Models","title":"Linear Models","text":"","category":"section"},{"location":"linearmodel.html#","page":"Linear Models","title":"Linear Models","text":"RobotDynamics supports the easy construction of linear models. By defining a linear model, the relevant dynamics and jacobian functions are predefined for you. This can result in signicant speed ups compared to a naive  specification of a standard continuous model. ","category":"page"},{"location":"linearmodel.html#","page":"Linear Models","title":"Linear Models","text":"LinearModel\nLinearizedModel","category":"page"},{"location":"linearmodel.html#Linearizing-and-Discretizing-a-Model-(experimental)-1","page":"Linear Models","title":"Linearizing and Discretizing a Model (experimental)","text":"","category":"section"},{"location":"linearmodel.html#","page":"Linear Models","title":"Linear Models","text":"Many systems with complicated nonlinear dynamics can be simplified by linearizing them about a fixed point or a trajectory. This can allow the use of specialized and faster trajectory optimization methods for these linear systems. The functions that RobotDynamics provides also discretize the system. ","category":"page"},{"location":"linearmodel.html#","page":"Linear Models","title":"Linear Models","text":"discretize!\nupdate_trajectory!","category":"page"},{"location":"linearmodel.html#Example-1","page":"Linear Models","title":"Example","text":"","category":"section"},{"location":"linearmodel.html#","page":"Linear Models","title":"Linear Models","text":"Take for example the cartpole, which can be readily linearized about it's stable point. We can use the  LinearizedModel to easily find the linearized system.","category":"page"},{"location":"linearmodel.html#","page":"Linear Models","title":"Linear Models","text":"using RobotDynamics\nimport RobotDynamics: dynamics  # the dynamics function must be imported\nusing StaticArrays\n\nconst RD = RobotDynamics\n\nstruct Cartpole{T} <: AbstractModel\n    mc::T  # mass of the cart\n    mp::T  # mass of the pole\n    l::T   # length of the pole\n    g::T   # gravity\nend\n\nfunction dynamics(model::Cartpole, x, u)\n    mc = model.mc   # mass of the cart in kg (10)\n    mp = model.mp   # mass of the pole j(point mass at the end) in kg\n    l = model.l     # length of the pole in m\n    g = model.g     # gravity m/s^2\n\n    q  = x[SA[1,2]]\n    qd = x[SA[3,4]]\n\n    s = sin(q[2])\n    c = cos(q[2])\n\n    H = SA[mc+mp mp*l*c; mp*l*c mp*l^2]\n    C = SA[0 -mp*qd[2]*l*s; 0 0]\n    G = SA[0, mp*g*l*s]\n    B = SA[1, 0]\n\n    qdd = -H\\(C*qd + G - B*u[1])\n    return [qd; qdd]\nend\n\nRD.state_dim(::Cartpole) = 4\nRD.control_dim(::Cartpole) = 1\n\nnonlinear_model = Cartpole(1.0, 1.0, 1.0, 9.81)\nn = state_dim(nonlinear_model)\nm = control_dim(nonlinear_model)\n\n# stationary point for the cartpole around which to linearize\nx̄ = @SVector [0., π, 0., 0.]\nū = @SVector [0.0]\ndt = 0.01\nknot_point = KnotPoint(x̄, ū, dt)\n\n# creates a new LinearizedModel around stationary point\nlinear_model = RD.LinearizedModel(nonlinear_model, knot_point, \n    dt=dt, integration=Exponential)\n\nδx = @SVector zeros(n)\nδu = @SVector zeros(m)\n\n# outputs linearized dynamics!\nδxₖ₊₁ = discrete_dynamics(PassThrough, linear_model, δx, δu, 0.0, dt) \n\n@assert δxₖ₊₁ ≈ zeros(n)\n\nF = RD.DynamicsJacobian(n,m)\ndiscrete_jacobian!(PassThrough, F, linear_model, knot_point)\n\n@show A = RD.get_A(F)\n@show B = RD.get_B(F)\n","category":"page"},{"location":"discretization.html#","page":"Discretization","title":"Discretization","text":"CurrentModule = RobotDynamics","category":"page"},{"location":"discretization.html#Discretization-1","page":"Discretization","title":"Discretization","text":"","category":"section"},{"location":"discretization.html#","page":"Discretization","title":"Discretization","text":"This page gives details on the methods for evaluating discretized dynamics, as well as instructions on how to define a custom integration method.","category":"page"},{"location":"discretization.html#Model-Discretization-1","page":"Discretization","title":"Model Discretization","text":"","category":"section"},{"location":"discretization.html#","page":"Discretization","title":"Discretization","text":"With a model defined, we can compute the discrete dynamics and discrete dynamics Jacobians for an explicit  integration rule with the following methods","category":"page"},{"location":"discretization.html#","page":"Discretization","title":"Discretization","text":"x′ = discrete_dynamics(Q, model, x, u, t, dt)\nx′ = discrete_dynamics(Q, model, z::KnotPoint)\ndiscrete_jacobian!(Q, ∇f, model, z::AbstractKnotPoint)","category":"page"},{"location":"discretization.html#","page":"Discretization","title":"Discretization","text":"For more information, see the docstrings for discrete_dynamics and  discrete_jacobian!.","category":"page"},{"location":"discretization.html#Integration-Schemes-1","page":"Discretization","title":"Integration Schemes","text":"","category":"section"},{"location":"discretization.html#","page":"Discretization","title":"Discretization","text":"RobotDynamics.jl has already defined a handful of integration schemes for computing discrete dynamics. The integration schemes are specified as abstract types, so that methods can efficiently dispatch based on the integration scheme selected. Here is the current set of implemented types:","category":"page"},{"location":"discretization.html#","page":"Discretization","title":"Discretization","text":"QuadratureRule\nExplicit\nRK2\nRK3\nRK4\nExponential\nPassThrough\nImplicit\nHermiteSimpson","category":"page"},{"location":"discretization.html#","page":"Discretization","title":"Discretization","text":"QuadratureRule\nRobotDynamics.Explicit\nRK2\nRK3\nRK4\nExponential\nPassThrough\nRobotDynamics.Implicit\nHermiteSimpson","category":"page"},{"location":"discretization.html#RobotDynamics.QuadratureRule","page":"Discretization","title":"RobotDynamics.QuadratureRule","text":"Integration rule for approximating the continuous integrals for the equations of motion\n\n\n\n\n\n","category":"type"},{"location":"discretization.html#RobotDynamics.Explicit","page":"Discretization","title":"RobotDynamics.Explicit","text":"Integration rules of the form x′ = f(x,u), where x′ is the next state\n\n\n\n\n\n","category":"type"},{"location":"discretization.html#RobotDynamics.RK4","page":"Discretization","title":"RobotDynamics.RK4","text":"Fourth-order Runge-Kutta method with zero-order-old on the controls\n\n\n\n\n\n","category":"type"},{"location":"discretization.html#RobotDynamics.Implicit","page":"Discretization","title":"RobotDynamics.Implicit","text":"Integration rules of the form x′ = f(x,u,x′,u′), where x′,u′ are the states and controls at the next time step.\n\n\n\n\n\n","category":"type"},{"location":"discretization.html#Defining-a-New-Integration-Scheme-1","page":"Discretization","title":"Defining a New Integration Scheme","text":"","category":"section"},{"location":"discretization.html#Explicit-Methods-1","page":"Discretization","title":"Explicit Methods","text":"","category":"section"},{"location":"discretization.html#","page":"Discretization","title":"Discretization","text":"Explicit integration schemes are understandably simpler, since the output is not a function of itself, as is the case with implict schemes. As such, as a minimum, the user only needs to define the following method for a new rule MyQ:","category":"page"},{"location":"discretization.html#","page":"Discretization","title":"Discretization","text":"abstract type MyQ <: RobotDynamics.Explicit end\nx′ = discrete_dynamics(::Type{MyQ}, model::AbstractModel, x, u, t, dt)","category":"page"},{"location":"discretization.html#","page":"Discretization","title":"Discretization","text":"which will make calls to the continuous-time dynamics function dynamics(model, x, u, t).","category":"page"},{"location":"discretization.html#","page":"Discretization","title":"Discretization","text":"Below is an example of the default integration method RK3, a third-order Runge-Kutta method:","category":"page"},{"location":"discretization.html#","page":"Discretization","title":"Discretization","text":"function discrete_dynamics(::Type{RK3}, model::AbstractModel,\n\t\tx::StaticVector, u::StaticVector, t, dt)\n    k1 = dynamics(model, x,             u, t       )*dt;\n    k2 = dynamics(model, x + k1/2,      u, t + dt/2)*dt;\n    k3 = dynamics(model, x - k1 + 2*k2, u, t + dt  )*dt;\n    x + (k1 + 4*k2 + k3)/6\nend","category":"page"},{"location":"discretization.html#Implicit-Methods-(experimental)-1","page":"Discretization","title":"Implicit Methods (experimental)","text":"","category":"section"},{"location":"discretization.html#","page":"Discretization","title":"Discretization","text":"Incorporating implicit integration methods is still under development (great option for     someone looking to contribute!).","category":"page"},{"location":"liemodel.html#","page":"Models with Rotations","title":"Models with Rotations","text":"CurrentModule = RobotDynamics","category":"page"},{"location":"liemodel.html#Models-with-Rotations-1","page":"Models with Rotations","title":"Models with Rotations","text":"","category":"section"},{"location":"liemodel.html#","page":"Models with Rotations","title":"Models with Rotations","text":"In robotics, the state of our robot often depends on one or more arbitrary 3D rotations (a.k.a. orientation, attitude). Effectively representing the non-trivial group structure of rotations has been a topic of study for over 100 years, and as a result many parameterizations exists. RobotDynamics supports the types defined in Rotations.jl.","category":"page"},{"location":"liemodel.html#","page":"Models with Rotations","title":"Models with Rotations","text":"The LieGroupModel type allows users to abstract away the particular rotation representation used and will automatically create efficient methods to handle the potentially different state dimensions that result. Additionally, it defines methods for operating on the error state, which for rotations is always three-dimensional. See the discussion in the Rotaitons.jl README for more information on the error state.","category":"page"},{"location":"liemodel.html#","page":"Models with Rotations","title":"Models with Rotations","text":"compat: Compat\nRobotDynamics requires v1.0 or higher of Rotations.jl","category":"page"},{"location":"liemodel.html#Defining-a-LieGroupModel-1","page":"Models with Rotations","title":"Defining a LieGroupModel","text":"","category":"section"},{"location":"liemodel.html#","page":"Models with Rotations","title":"Models with Rotations","text":"We define a LieGroupModel very similarly to that of a standard model. For this example, let's assume we are modeling a constellation of 2 satellites and we only care about the attitude dynamics. We will define our state to be [q1, ω1, q2, ω2] where qi and ωi are the orientation  and angular velocity of the ith satellite, respectively.","category":"page"},{"location":"liemodel.html#","page":"Models with Rotations","title":"Models with Rotations","text":"We start by defining our new type and our dynamics function","category":"page"},{"location":"liemodel.html#","page":"Models with Rotations","title":"Models with Rotations","text":"struct SatellitePair{R,T} <: LieGroupModel\n    J1::SMatrix{3,3,T,9}   # inertia of satellite 1\n    J2::SMatrix{3,3,T,9}   # inertia of satellite 2\nend\n\nfunction RobotDynamics.dynamics(model::SatellitePair, x, u)\n    vs = RobotDynamics.vec_states(model, x)  # extract \"vector\" states\n    qs = RobotDynamics.rot_states(model, x)  # extract attitude states\n    ω1 = vs[2]  # offset index by 1 since there are now \"vector\" states before the first quaternion\n    ω2 = vs[3]\n    q1 = qs[1]\n    q2 = qs[2]\n\n    J1, J2 = model.J1, model.J2\n    u1 = u[SA[1,2,3]]\n    u2 = u[SA[4,5,6]]\n    ω1dot = J1\\(u1 - ω1 × (J1 * ω1))\n    ω2dot = J2\\(u2 - ω2 × (J2 * ω2))\n    q1dot = Rotations.kinematics(q1, ω1)\n    q2dot = Rotations.kinematics(q2, ω2)\n    SA[\n        q1dot[1], q1dot[2], q1dot[3], q1dot[4],\n        ω1dot[1], ω1dot[2], ω1dot[3],\n        q2dot[1], q2dot[2], q2dot[3], q2dot[4],\n        ω2dot[1], ω2dot[2], ω2dot[3],\n    ]\nend\n\nRobotDynamics.control_dim(::SatellitePair) = 6","category":"page"},{"location":"liemodel.html#","page":"Models with Rotations","title":"Models with Rotations","text":"Before defining the functions vec_states and rot_states, we will define the type LieState, which defines how our state vector is stacked or partitioned. The LieState only needs to know how many \"vector\" or \"non-rotation\" states exist, and where the rotations are placed in the state vector. In our example, we have a rotation, followed by 3 \"vector\" states, followed by a rotation, followed by 3 \"vector\" states, so we would define our LieState to be","category":"page"},{"location":"liemodel.html#","page":"Models with Rotations","title":"Models with Rotations","text":"RobotDynamics.LieState(::SatellitePair{R}) where R = RobotDynamics.LieState(R, (0,3,3))","category":"page"},{"location":"liemodel.html#","page":"Models with Rotations","title":"Models with Rotations","text":"which means we have a state with 0 vector states at the beginning, followed by a rotation, followed by 3 vector states, followed by a rotation, followed by 3 vector states, and the rotation type is R.","category":"page"},{"location":"liemodel.html#","page":"Models with Rotations","title":"Models with Rotations","text":"With this partitioning in mind, we can now understand the behavior of vec_states and rot_states, which simply extract the vector and attitude parts of the state as tuples of SVectors.","category":"page"},{"location":"liemodel.html#LieGroupModel-API-1","page":"Models with Rotations","title":"LieGroupModel API","text":"","category":"section"},{"location":"liemodel.html#","page":"Models with Rotations","title":"Models with Rotations","text":"RobotDynamics.LieGroupModel\nRobotDynamics.LieState\nRobotDynamics.QuatState\nRobotDynamics.vec_states\nRobotDynamics.rot_states","category":"page"},{"location":"liemodel.html#RobotDynamics.LieGroupModel","page":"Models with Rotations","title":"RobotDynamics.LieGroupModel","text":"LieGroupModel <: AbstractModel\n\nAbstraction of a dynamical system whose state contains at least one arbitrary rotation.\n\n\n\n\n\n","category":"type"},{"location":"liemodel.html#RobotDynamics.LieState","page":"Models with Rotations","title":"RobotDynamics.LieState","text":"LieState{R,P}\n\nSpecifies a state with rotational components mixed in with standard vector components. All rotational components are assumed to be parameterizations of 3D rotations.\n\nParameters\n\nR <: Rotation is the rotational representation used in the state vector. Must have\n\nparams(::Type{R}) defined, which returns the number of parameters used by the rotation, as well a constructor that takes each parameter as a separate scalar argument.\n\nP <: Tuple{Vararg{Int}} is a tuple of integers specifying the partitioning of the state\n\nvector. Each element of P specifies the length of the vector component between the rotational components, and P[1] and P[end] specify the number of vector states at the beginning and end of the state vector.\n\nExamples\n\nIf we want to construct a state vector like the following: [v3, q, v2, q, v3] where v2 and v3 and vector components of length 2 and 3, respectively, and q is a 4-dimensional unit quaternion. The LieState for this state vector would be LieState{UnitQuaternion{Float64},3,2,3}. The length should be (3+4+2+4+3) = 16, which can be verified by length(s::LieState).\n\nConstructors\n\nLieState(::Type{R}, P::Tuple{Vararg{Int}})\nLieState(::Type{R}, p1::Int, p2::Int, p3::Int...)\n\n\n\n\n\n","category":"type"},{"location":"liemodel.html#RobotDynamics.QuatState","page":"Models with Rotations","title":"RobotDynamics.QuatState","text":"QuatState(n::Int, Q::StaticVector{<:Any,Int})\nQuatState(n::Int, Q::NTuple{<:Any,Int})\n\nCreate a n-dimensional LieState assuming R = UnitQuaternion{Float64} and Q[i] is the first index of each quaternion in the state vector.\n\nExample\n\nIf we want to construct a state vector like the following: [v3, q, v2, q, v3] where v2 and v3 and vector components of length 2 and 3, respectively, and q is a 4-dimensional unit quaternion. Since the first quaternion starts at index 4, and the second starts at index 10, Q = [4,10]. The entire length of the vector is n = 16 = 3 + 4 + 2 + 4 + 3, so we would call QuatState(16, SA[4,10]).\n\n\n\n\n\n","category":"function"},{"location":"liemodel.html#RobotDynamics.vec_states","page":"Models with Rotations","title":"RobotDynamics.vec_states","text":"vec_states(model::LieGroupModel, x)\nvec_states(s::LieState, x)\n\nExtracts the \"vector\" states out of the state vector x for a LieGroupModel. Returns a tuple v of SVectors, where length(v[i]) is equal to the length specified by the LieState.\n\n\n\n\n\n","category":"function"},{"location":"liemodel.html#RobotDynamics.rot_states","page":"Models with Rotations","title":"RobotDynamics.rot_states","text":"vec_states(model::LieGroupModel, x)\nvec_states(s::LieState, x)\n\nExtracts the rotations out of the state vector x for a LieGroupModel. Returns a tuple rotations, whose type matches the rotation type specified in the LieState.\n\n\n\n\n\n","category":"function"},{"location":"finite_diff.html#","page":"Finite Differencing","title":"Finite Differencing","text":"CurrentModule = RobotDynamics","category":"page"},{"location":"finite_diff.html#Finite-Differencing-1","page":"Finite Differencing","title":"Finite Differencing","text":"","category":"section"},{"location":"finite_diff.html#","page":"Finite Differencing","title":"Finite Differencing","text":"RobotDynamics allows the Jacobians to be calculated using finite  differencing via FiniteDiff.jl instead of forward-mode automatic differentiation via ForwardDiff.jl. ForwardDiff tends to be faster, and obviously provides more accurate  derivatives, but finite differencing will always work, even through lookup tables, calling external code, or other functions that may be  difficult to diff through using ForwardDiff.","category":"page"},{"location":"finite_diff.html#","page":"Finite Differencing","title":"Finite Differencing","text":"To use finite differencing, set the diffmethod trait to RobotDynamics.FiniteDifference().  For example, if we want to use finite differencing for the cartpole we can use the following line of code:","category":"page"},{"location":"finite_diff.html#","page":"Finite Differencing","title":"Finite Differencing","text":"RobotDynamics.diffmethod(::Cartpole) = RobotDynamics.FiniteDifference()","category":"page"},{"location":"finite_diff.html#","page":"Finite Differencing","title":"Finite Differencing","text":"The interface is exactly the same:","category":"page"},{"location":"finite_diff.html#","page":"Finite Differencing","title":"Finite Differencing","text":"model = Cartpole()\nz = KnotPoint(rand(model)..., 0.1)\nF = RobotDynamics.DynamicsJacobian(model)\njacobian!(F, model, z)","category":"page"},{"location":"finite_diff.html#","page":"Finite Differencing","title":"Finite Differencing","text":"To acheive zero allocation with FiniteDiff.jl, we need to pass in a JacobianCache.  We can define this directly from the model and pass it to the Jacobian function:","category":"page"},{"location":"finite_diff.html#","page":"Finite Differencing","title":"Finite Differencing","text":"cache = FiniteDiff.JacobianCache(model)\ndiscrete_jacobian!(RK4, F, model, z, cache)","category":"page"},{"location":"finite_diff.html#","page":"Finite Differencing","title":"Finite Differencing","text":"The difference method, datatype, and other options can be modified via the  JacobianCache constructor:","category":"page"},{"location":"finite_diff.html#","page":"Finite Differencing","title":"Finite Differencing","text":"cache = FiniteDiff.JacobianCache(model, Val(:central), Float64)","category":"page"},{"location":"index.html#RobotDynamics.jl-1","page":"Introduction","title":"RobotDynamics.jl","text":"","category":"section"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"Welcome to RobotDynamics.jl! This package is dedicated to providing a convenient interface for defining the dynamics of forced dynamical systems, such as robots.","category":"page"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"This package also provides many efficient methods for evaluating dynamics, their Jacobians, and their discrete-time versions for use in optimization packages such as TrajectoryOptimization.jl.","category":"page"},{"location":"dynamics_evaluation.html#model_section-1","page":"2. Evaluating the Dynamics","title":"2. Evaluating the Dynamics","text":"","category":"section"},{"location":"dynamics_evaluation.html#","page":"2. Evaluating the Dynamics","title":"2. Evaluating the Dynamics","text":"CurrentModule = RobotDynamics","category":"page"},{"location":"dynamics_evaluation.html#","page":"2. Evaluating the Dynamics","title":"2. Evaluating the Dynamics","text":"Pages = [\"dynamics_evaluation.md\"]","category":"page"},{"location":"dynamics_evaluation.html#Overview-1","page":"2. Evaluating the Dynamics","title":"Overview","text":"","category":"section"},{"location":"dynamics_evaluation.html#","page":"2. Evaluating the Dynamics","title":"2. Evaluating the Dynamics","text":"Once we have a model defined as detailed on the previous page, we can query both the continuous and discrete dynamics, and have access to some additional, useful methods.","category":"page"},{"location":"dynamics_evaluation.html#Querying-the-Continuous-Dynamics-1","page":"2. Evaluating the Dynamics","title":"Querying the Continuous Dynamics","text":"","category":"section"},{"location":"dynamics_evaluation.html#","page":"2. Evaluating the Dynamics","title":"2. Evaluating the Dynamics","text":"We can evaluate the continuous dynamics using one of the following methods:","category":"page"},{"location":"dynamics_evaluation.html#","page":"2. Evaluating the Dynamics","title":"2. Evaluating the Dynamics","text":"ẋ = dynamics(model, z)\nẋ = dynamics(model, x, u)\nẋ = dynamics(model, x, u, t)","category":"page"},{"location":"dynamics_evaluation.html#","page":"2. Evaluating the Dynamics","title":"2. Evaluating the Dynamics","text":"where z is an AbstractKnotPoint, x is the n-dimensional state vector, u is the m-dimensional control vector, and t is the positive scalar independent variable, typically time. For best performance, x and u should be SVectors.","category":"page"},{"location":"dynamics_evaluation.html#","page":"2. Evaluating the Dynamics","title":"2. Evaluating the Dynamics","text":"We can evaluate the continuous time dynamics Jacobian using the method","category":"page"},{"location":"dynamics_evaluation.html#","page":"2. Evaluating the Dynamics","title":"2. Evaluating the Dynamics","text":"jacobian!(∇f, model, z)","category":"page"},{"location":"dynamics_evaluation.html#","page":"2. Evaluating the Dynamics","title":"2. Evaluating the Dynamics","text":"where ∇f is an n × (n+m) matrix. Note that the Jacobian methods require an AbstractKnotPoint, since this eliminates unnecessary concatenation and subsequent memory allocations when using ForwardDiff.","category":"page"},{"location":"dynamics_evaluation.html#The-DynamicsJacobian-type-1","page":"2. Evaluating the Dynamics","title":"The DynamicsJacobian type","text":"","category":"section"},{"location":"dynamics_evaluation.html#","page":"2. Evaluating the Dynamics","title":"2. Evaluating the Dynamics","text":"While the dynamics Jacobian ∇f can be any AbstractMatrix, RobotDynamics provides the DynamicsJacobian type that has some convenient constructors and provides access to the individual partial derivatives:","category":"page"},{"location":"dynamics_evaluation.html#","page":"2. Evaluating the Dynamics","title":"2. Evaluating the Dynamics","text":"DynamicsJacobian","category":"page"},{"location":"dynamics_evaluation.html#RobotDynamics.DynamicsJacobian","page":"2. Evaluating the Dynamics","title":"RobotDynamics.DynamicsJacobian","text":"DynamicsJacobian{n,nm,T}\n\nCustom n × (n+m) matrix specifying a dynamics Jacobian for a forced dynamical system with n states and m controls. The Jacobian is structured as [∂x ∂u] where x and u are the state and control vectors, respectively.\n\nThe DynamicsJacobian D provides access to the partial derivatives A = ∂x  and B = ∂u via direct access D.A and D.B, returning a view into the underlying Matrix, or\n\nRobotDynamics.get_A(D)\nRobotDynamics.get_B(D)\n\nwhich return an SMatrix. Note that this method should be used with caution for systems with large state and/or control dimensions.\n\nConstructors\n\nDynamicsJacobian(model::AbstractModel)\nDynamicsJacobian(n::Int, m::Int)\nDynamicsJacobian(D::StaticMatrix)\n\nwhere D is a StaticMatrix of appropriate size. Since DynamicsJacobian implements the StaticMatrix interface, is also supports all the constructors and operations inherent to a StaticMatrix.\n\n\n\n\n\n","category":"type"},{"location":"dynamics_evaluation.html#Querying-Discrete-Dynamics-1","page":"2. Evaluating the Dynamics","title":"Querying Discrete Dynamics","text":"","category":"section"},{"location":"dynamics_evaluation.html#","page":"2. Evaluating the Dynamics","title":"2. Evaluating the Dynamics","text":"The discrete dynamics can be evaluated using methods analogous to those used to evaluate the continuous dynamics, except we now need to specify the integration method and the time step.","category":"page"},{"location":"dynamics_evaluation.html#","page":"2. Evaluating the Dynamics","title":"2. Evaluating the Dynamics","text":"x′ = discrete_dynamics(::Type{Q}, model, z)\nx′ = discrete_dynamics(::Type{Q}, model, x, u, t, dt)","category":"page"},{"location":"dynamics_evaluation.html#","page":"2. Evaluating the Dynamics","title":"2. Evaluating the Dynamics","text":"where Q is a QuadratureRule. See Discretization for more information on the integration methods defined in RobotDynamics.","category":"page"},{"location":"dynamics_evaluation.html#","page":"2. Evaluating the Dynamics","title":"2. Evaluating the Dynamics","text":"When evaluating discrete dynamics, one can also use the propagate_dynamics method that updates the state of the next KnotPoint:","category":"page"},{"location":"dynamics_evaluation.html#","page":"2. Evaluating the Dynamics","title":"2. Evaluating the Dynamics","text":"propagate_dynamics","category":"page"},{"location":"dynamics_evaluation.html#","page":"2. Evaluating the Dynamics","title":"2. Evaluating the Dynamics","text":"The discrete dynamics Jacobian is similarly evaluated using","category":"page"},{"location":"dynamics_evaluation.html#","page":"2. Evaluating the Dynamics","title":"2. Evaluating the Dynamics","text":"discrete_jacobian!(::Type{Q}, ∇f, model, z)","category":"page"},{"location":"dynamics_evaluation.html#","page":"2. Evaluating the Dynamics","title":"2. Evaluating the Dynamics","text":"If the integration method is not passed in as the first argument, the default integration method RK3 will be used.","category":"page"},{"location":"dynamics_evaluation.html#Other-Methods-1","page":"2. Evaluating the Dynamics","title":"Other Methods","text":"","category":"section"},{"location":"dynamics_evaluation.html#","page":"2. Evaluating the Dynamics","title":"2. Evaluating the Dynamics","text":"All AbstractModels provide a few functions for generating state and control vectors directly from the model:","category":"page"},{"location":"dynamics_evaluation.html#","page":"2. Evaluating the Dynamics","title":"2. Evaluating the Dynamics","text":"x,u = zeros(model)\nx,u = rand(model)\nx,u = fill(model, value)","category":"page"},{"location":"dynamics_evaluation.html#","page":"2. Evaluating the Dynamics","title":"2. Evaluating the Dynamics","text":"The Base.size method is also overloaded as a shortcut for returning state_dim(model) and control_dim(model) as a tuple:","category":"page"},{"location":"dynamics_evaluation.html#","page":"2. Evaluating the Dynamics","title":"2. Evaluating the Dynamics","text":"n,m = size(model)","category":"page"}]
}
